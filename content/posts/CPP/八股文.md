+++
title = '八股文'
date = 2024-03-30T09:10:50+08:00
draft = true
series = ["CPlusPlus"]
+++

#### 多态
C++中的多态是一种允许使用统一的接口来操作不同类型对象的特性。多态性是面向对象编程（OOP）的核心概念之一，多态主要有两种形式：静态多态（编译时多态）和动态多态（运行时多态）。

- 静态多态（编译时多态）
静态多态是在编译时实现的，主要通过函数重载和模板（泛型编程）实现。

  - 函数重载：允许在相同作用域内创建多个同名函数，只要它们的参数列表不同（参数类型或参数个数不同）。
  - 模板：允许创建可应用于任意数据类型的函数或类。

- 动态多态（运行时多态）
动态多态是在程序运行时实现的，主要通过虚函数和继承来实现。

  - 虚函数：在基类中声明的函数，可以在派生类中被重写。当通过基类指针或引用调用虚函数时，会根据指针或引用所指向的对象的实际类型来调用相应的函数，这种机制称为动态绑定或晚绑定。
  - 继承：允许创建基于现有类的新类，继承其属性和方法。派生类可以覆盖（重写）基类中的虚函数，实现运行时多态。
    动态多态的实现依赖于C++的虚函数表（vtable），这是一种在每个含有虚函数的类的对象中维护的函数指针数组。当调用虚函数时，运行时系统会根据对象的实际类型查找虚函数表，以确定调用哪个函数。

#### lambda
C++中的Lambda表达式是一种定义匿名函数对象的方式，自C++11引入
```cpp
[ capture ] ( parameters ) -> return_type {
    function_body
}
```
Lambda表达式的基本语法如下：
  - capture：捕获列表，定义了Lambda表达式体内部可以访问的外部变量。它可以为空，或包含一系列用逗号分隔的变量。这些变量可以通过值（=）或引用（&）捕获
  - parameters：参数列表，与普通函数的参数列表类似。对于不接受参数的Lambda，可以省略参数列表或使用一对空括号 ()
  - return_type：返回类型，可选。如果Lambda体包含单一的返回语句，或不返回任何值（即返回void），则可以省略返回类型，编译器会自动推导
  - function_body：函数体，包含了Lambda表达式的代码逻辑
捕获列表
捕获列表允许Lambda表达式访问它所在作用域中的变量。有几种捕获模式：
- []：不捕获任何外部变量
- [x]：通过值捕获外部变量x
- [&x]：通过引用捕获外部变量x
- [=]：通过值捕获所有外部变量 (注意性能开销)
- [&]：通过引用捕获所有外部变量
- [&, x]：通过引用捕获所有外部变量，但是通过值捕获x
- [=, &x]：通过值捕获所有外部变量，但是通过引用捕获x
作为入参的方式
- 使用`std::function`，这是一个泛型函数包装器，灵活
- 使用模板，最为灵活，性能比用`std::function`低
- 使用函数指针,只有没有捕获任何外部变量的lambda表达式可以转换成函数指针

#### 分配内存要考虑的问题
- 内存泄漏：分配了内存但没有释放，导致程序运行时内存不断累积，最终可能耗尽可用内存。解决方法是在不需要使用内存时及时释放。
- 重复释放：对同一块内存多次释放会导致程序崩溃或不可预测的行为。解决方法是避免重复释放同一块内存。
- 野指针：指向已释放内存的指针称为野指针，访问野指针会导致程序崩溃或不可预测的行为。解决方法是在释放内存后将指针置为nullptr。
- 内存越界：访问超出分配内存范围的内存会导致程序崩溃或不可预测的行为。解决方法是确保访问的内存范围不超出分配的范围。
- 内存对齐：某些平台要求内存按照一定的字节对齐方式分配，不正确的内存对齐可能导致性能问题或程序崩溃。解决方法是根据平台要求正确对齐内存。
- 内存拷贝：在使用动态内存分配时，需要注意拷贝指针指向的内存而不是指针本身，否则可能导致两个指针指向同一块内存，释放时会出错。
- 内存分配效率：频繁的内存分配和释放会影响程序性能，可以通过对象池、内存池等方式提高内存分配效率。
- 异常安全：在分配内存时要考虑异常安全，即当内存分配失败时程序能够正常处理，避免资源泄漏。
#### 避免内存泄漏的方法
- 手动释放内存
- 使用智能指针
- 避免循环引用
- RAII（资源获取即初始化）是一种设计模式，核心思想是将资源的获取（Acquisition）与对象的初始化（Initialization）捆绑在一起，同时将资源的释放与对象的析构（Destruction）捆绑在一起。
- 内存检测工具：Valgrind、Dr.Memory等



