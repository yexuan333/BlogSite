+++
title = 'CPP函数（Doing）'
date = 2023-12-31T23:55:23+08:00
draft = false
series = ["CPlusPlus"]
+++
##### 函数原型
###### 什么是原型
函数原型是一条语句，以`;`结束，一般放在头文件中，如:
```cpp
void add(int a,int b);
```
###### 为什么需要原型
C++的底层编译为了与C兼容，继承了C语言编译的大部分特点，采用类似**单遍编译**的做法，编译器按顺序处理源代码文件。当编译器遇到一个函数调用时，它必须已经知道这个函数的签名（即函数原型），否则会产生编译错误。这就是为什么 C++ 需要在调用函数之前声明函数原型的原因。

###### 右值引用
右值引用是 C++11 引入的一种引用类型，它绑定到临时对象（即右值）上。使用 `&&` 操作符表示右值引用。右值引用允许函数接收一个即将销毁的临时对象。当函数需要接收一个临时对象并希望避免复制或修改该对象时使用。
```cpp
void function(int&& param) {
    // 使用右值引用
}
function(1); // 1就是右值
```
##### 变量遮蔽
如果在函数外有一个变量 x，然后在函数内部重新声明了一个同名的变量 x，这种行为称为“变量遮蔽”或“局部遮蔽”
```cpp
int x = 10; // 全局变量

void myFunction() {
    int x = 20; // 局部变量，遮蔽了全局变量 x
    // 在这个作用域内，x 指的是局部变量，会在退出函数的时候释放这个变量
}

int main() {
    myFunction();
    // 在这个位置，x 指的是全局变量
    return 0;
}
```
##### 内联函数
内联函数是一种在调用点展开的函数,避免了常规函数调用的一些开销，如参数传递、栈操作等。通常用于简单、频繁调用的小型函数。

在头文件中定义，即使没做头文件保护，因为自动展开的原因，所以不会造成多重定义的错误

在源文件中定义，会失去内联的优势，可能只能在定义内联函数的文件中自动展开了，因为在编译其他源文件时，编译器看不到内联函数的定义。
```cpp
inline print(int a) {
    std::cout << a;
}
void main(){
    add(1);
    add(2);
}
```
上面的代码会在编译的时候展开成如下
```cpp
void main(){
    {
        a = 1;
        std::cout << a;
    }
    {
        a = 2;
        std::cout << a;
    }
}
```

##### 临时变量
函数参数的临时变量是在函数调用过程中创建的局部变量，用于存储传递给函数的参数值。通常在栈上分配。
会在以下条件中创建
- 值传递
  - 为每个值传递实参创建一个临时变量。
- 引用传递（左值引用`&`）
  - 实参的类型正确时，但是是右值，所以没有名称，将生成一个临时的匿名变量
  - 实参的类型不正确，为了转换成正确的类型，将生成一个临时的匿名变量
**创建了临时变量，对参数传递的变量的修改将无效**

##### 函数重载
函数重载是指在同一作用域内创建多个具有相同名称但参数列表不同的函数。
**函数重载的实现机制**
名称修饰（Name Mangling）是编译器用来支持函数重载的一种技术。在这个过程中，编译器会修改函数名，将函数的参数类型和数量编码到名称中。
**函数重载的规则**
- 相同函数名：重载的函数必须具有相同的函数名。
- 不同参数列表：参数的个数或类型必须不同。
- 返回类型：仅返回类型的不同不足以构成重载。
```cpp
void print(int i) {
}
void print(double f) {
}
void print(int i, double f) {
} 
```
##### 函数模板
- **函数模板实例化**
  - 隐式实例化,当模板函数被调用时，编译器根据提供的参数类型自动生成一个特定的函数实例
  - 显式实例化,可以显式地指定模板实例的类型
- **函数模板具体化**：创建一个特定版本的模板函数，以适应特定类型或条件的需求。
```cpp
template <class T> // 模板函数
T Operator(T a, T b) {
    return a + b;
} 

template <> //模板具体化类型为int
int Operator<int>(int a, int b) {
    return a * b;
}

int main(int argc, char* argv[]) {
    std::cout << Operator(1.0, 1.0) << std::endl; //模板隐式实例化T为double类型
    // >>2
    std::cout << Operator(1, 1) << std::endl; //模板隐式实例化T为int类型
    // >>1
    std::cout << Operator<int>(1.0, 1.0) << std::endl; ////模板显示实例化T为int类型,会将double转换为int
    // >>1
    std::system("pause");
}
```