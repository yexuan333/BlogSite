+++
title = 'CPP函数（Doing）'
date = 2023-12-31T23:55:23+08:00
draft = false
series = ["CPlusPlus"]
+++

## 函数定义和声明
##### 函数声明（函数原型）
函数原型是一条语句，以`;`结束，一般放在头文件中，如:
```cpp
void add(int a,int b);
```
###### 为什么需要原型
C++的底层编译为了与C兼容，继承了C语言编译的大部分特点，采用类似**单遍编译**的做法，编译器按顺序处理源代码文件。当编译器遇到一个函数调用时，它必须已经知道这个函数的签名（即函数原型），否则会产生编译错误。这就是为什么 C++ 需要在调用函数之前声明函数原型的原因。
##### 函数定义
函数定义提供了函数的具体实现

## 参数和返回值
###### 右值引用
右值引用是 C++11 引入的一种引用类型，它绑定到临时对象（即右值）上。使用 `&&` 操作符表示右值引用。右值引用允许函数接收一个即将销毁的临时对象。当函数需要接收一个临时对象并希望避免复制或修改该对象时使用。
```cpp
void function(int&& param) {
    // 使用右值引用
}
function(1); // 1就是右值
```

##### 变量遮蔽
如果在函数外有一个变量 x，然后在函数内部重新声明了一个同名的变量 x，这种行为称为“变量遮蔽”或“局部遮蔽”
```cpp
int x = 10; // 全局变量

void myFunction() {
    int x = 20; // 局部变量，遮蔽了全局变量 x
    // 在这个作用域内，x 指的是局部变量，会在退出函数的时候释放这个变量
}

int main() {
    myFunction();
    // 在这个位置，x 指的是全局变量
    return 0;
}
```

##### 临时变量
函数参数的临时变量是在函数调用过程中创建的局部变量，用于存储传递给函数的参数值。通常在栈上分配。
会在以下条件中创建
- 值传递
  - 为每个值传递实参创建一个临时变量。
- 引用传递（左值引用`&`）
  - 实参的类型正确时，但是是右值，所以没有名称，将生成一个临时的匿名变量
  - 实参的类型不正确，为了转换成正确的类型，将生成一个临时的匿名变量
**创建了临时变量，对参数传递的变量的修改将无效**

## 内联函数
内联函数是一种在调用点展开的函数,避免了常规函数调用的一些开销，如参数传递、栈操作等。通常用于简单、频繁调用的小型函数。

在头文件中定义，即使没做头文件保护，因为自动展开的原因，所以不会造成多重定义的错误

在源文件中定义，会失去内联的优势，可能只能在定义内联函数的文件中自动展开了，因为在编译其他源文件时，编译器看不到内联函数的定义。
```cpp
inline print(int a) {
    std::cout << a;
}
void main(){
    add(1);
    add(2);
}
```
上面的代码会在编译的时候展开成如下
```cpp
void main(){
    {
        a = 1;
        std::cout << a;
    }
    {
        a = 2;
        std::cout << a;
    }
}
```


## 函数重载
函数重载是指在同一作用域内创建多个具有相同名称但参数列表不同的函数。
**函数重载的实现机制**
名称修饰（Name Mangling）是编译器用来支持函数重载的一种技术。在这个过程中，编译器会修改函数名，将函数的参数类型和数量编码到名称中。
**函数重载的规则**
- 相同函数名：重载的函数必须具有相同的函数名。
- 不同参数列表：参数的个数或类型必须不同。
- 返回类型：仅返回类型的不同不足以构成重载。
```cpp
void print(int i) {
}
void print(double f) {
}
void print(int i, double f) {
} 
```

## 函数的存储持续性
所有函数的存储持续性都自动为**静态**的，即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为**外部**的，即可以在文件间共享。还可以使用关键字 `static` 将函数的链接性设置为**内部**的，使之只能在一个文件中使用。

## 语言链接性
- C 语言没有重载函数，C 语言编译器可能将 spiff 这样的函数名翻译为_spiff。这种方法被称为 **C语
言链接性（C language linkage）**
- C++中有重载函数，C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。例如，可能将 spiff（int）转换为_spoff_i，而将 spiff（double，double）转换为_spiff_d_d。这种方法被称为**C++语言链接（C++ language linkage）**

可以用函数原型来指出要使用的约定
```cpp
extern "C" void f(int); // use C protocol(协议) for name
extern "C++" void f(int); // use C++ protocol for name
extern void f(int); // use C++ protocol for name
```