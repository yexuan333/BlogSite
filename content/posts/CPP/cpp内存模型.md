+++
title = 'Cpp内存模型（Doing）'
date = 2024-01-06T23:49:48+08:00
draft = false
series = ["CPlusPlus"]
+++


#### 头文件内容
- 函数原型。
- 使用#define 或 const 定义的符号常量。
- 结构声明。
- 类声明。
- 模板声明。
- 内联函数的原型与定义。

#### #includ
- #includ "a.h":编译器优先在当前的工作目录或源代码目录（或其他目录，这取决于编译器）。
- #includ <a.h>:编译器优先在标准库头文件或第三方库头文件中查找
#### 头文件保护
头文件被不同的源文件多次引用，可能会造成多重定义，这将导致编译错误。
- 依赖不重复的宏名称
    ```cpp
    #ifndef MYFUNCTION_H
    #define MYFUNCTION_H

    void myFunction() {}

    #endif // MYFUNCTION_H
    ```
- `#pragma once`：由编译器提供保证，同一个文件不会被编译多次。


C++使用三种（在 C++11中是四种）不同的方案来存储数据
## 变量的存储持续性
**自动存储持续性**：在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放
- **自动变量**：如通过`auto`声明的，在函数定义中声明的变量，包括函数参数
- **~~~寄存器变量(弃用不推荐)~~~**~~~：通过`register`声明~~~

**静态存储持续性**：静态持续变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为 0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为 0，这被称为**零初始化**，还可对静态变量进行**常量表达式初始化**和**动态初始化**，零初始化和常量表达式初始化被统称为**静态初始化**，这意味着在编译器处理文件时初始化变量。动态初始化意味着变量将在编译后初始化
- **静态，外部链接性**：在函数外部声明，对其他文件可见，如果要在其他文件中使用外部变量，需要用`extern`声明如
  ```cpp a.h
  // file 1
  int globalVar;
  //-----------------------------------
  //file 2
  extern int globalVar;
  ```
- **静态变量，内部链接性**：在函数外部声明，只对所在文件可见
  ```cpp
  static int internalVar1;
  const int internalVar2; //const 全局变量的链接性为内部的。
  ```
- **静态变量，无链接性**：在函数内部声明，，只对对所在函数可见，<u>不随函数结束就释放，即使函数不处于活动状态也存在</u>
  ```cpp
  void fun(){
      static int Var;
  }
  ```

**线程存储持续性（C++11）**：生命周期与所属的线程一样长
- **thread_local**：可与 `static` 或 `extern` 结合使用如
  ```cpp
  thread_local static int myVar = 1;
  ```

**动态存储持续性(自由存储、堆)**：用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。这种内存的存储持续性为动态


## 函数的存储持续性
所有函数的存储持续性都自动为**静态**的，即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为**外部**的，即可以在文件间共享。还可以使用关键字 `static` 将函数的链接性设置为**内部**的，使之只能在一个文件中使用。

**语言链接性**
- C 语言没有重载函数，C 语言编译器可能将 spiff 这样的函数名翻译为_spiff。这种方法被称为 **C语
言链接性（C language linkage）**
- C++中有重载函数，C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。例如，可能将 spiff（int）转换为_spoff_i，而将 spiff（double，double）转换为_spiff_d_d。这种方法被称为**C++语言链接（C++ language linkage）**
可以用函数原型来指出要使用的约定
```cpp
extern "C" void f(int); // use C protocol(协议) for name
extern "C++" void f(int); // use C++ protocol for name
extern void f(int); // use C++ protocol for name
```
