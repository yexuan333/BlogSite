+++
title = 'CPP语法（Doing）'
date = 2023-12-31T19:26:49+08:00
draft = false
series = ["CPlusPlus"]
+++

## 基本数据类型
基本数据类型包括整型、浮点型、字符型和布尔型。
- **简单类型**
  - 整型
    - `short`：2字节，$(-2^{15},2^{15}-1)$。
    - `int`：4字节，$(-2^{31},2^{31}-1)$。
    - `long`：4字节（Windows，Linux32），8字节(Linux64)
    - `long long`：8字节，$(-2^{63},2^{63}-1)$。
  - 浮点型
    - `float`：4字节，7位有效数字
    - `double`：8字节，15～16位有效数字
  - 字符型
    - `char`：1字节。
    - `wchar_t`：2字节（Windows），4字节（Linux）
  - 布尔型
      - `bool`：1字节。
- **复合类型**
  - **数组**：用于存储相同类型的多个元素。之所以数组是复合类型是因为数组需要其他类型来创建，如`int []`
    ```cpp
    int myArray[10]; // 声明一个包含10个整数的数组
    int myArray2[5] = {1, 2, 3, 4, 5}; // 初始化一个整数数组
    int size = sizeof(myArray) / sizeof(myArray[0]); // 数组长度
    ```
  - **字符串**：字符串是字符序列。主要有两种类型的字符串表示方法：C 风格字符串和 C++ 风格字符串。
    - C风格，`char []`，使用 null 终止字符 (`'\0'`) 的字符数组。
    - C++风格， `std::string`表示
  - **指针**：用于存储变量的内存地址
  - **结构体**（Struct）：用于将不同类型的数据项组合成一个单元
    - 默认的成员访问权限是 public
    - 默认的继承类型是 public
    - 与C兼容，class不能
  - **联合体**（Union）：允许在相同的内存位置存储不同的数据类型，但一次只能使用其中一种类型
    - 所有成员共享同一块内存空间。用于节省内存，内存大小为最大成员的大小
    - 联合体的一个成员被赋值后，其他成员将变得不可访问
    ```cpp
    union MyUnion {
        int intValue;
        float floatValue;
        char charValue;
    };
    ```
  - **枚举**（Enum）：用于定义一组命名的整型常量
    - 使用 `enum` 关键字定义枚举类型。默认情况下，枚举的第一个元素的值是 0，后续元素的值依次增加。
    - 枚举类（C++11），使用 enum class 定义更严格的枚举类型。具有作用域限制，避免了传统枚举的命名冲突问题。比传统枚举提供更好的类型安全。

##  控制结构
- 条件语句（if, switch-case）
- 循环语句（for, while, do-while）
- 跳转语句（break, continue, goto）

##  运算符与表达式

## 变量
C++使用三种（在 C++11中是四种）不同的方案来存储数据
### 变量的存储持续性
#### 自动存储持续性
在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放
- **自动变量**：如通过`auto`声明的，在函数定义中声明的变量，包括函数参数
- **~~~寄存器变量(弃用不推荐)~~~**~~~：通过`register`声明~~~



#### 静态存储持续性
静态持续变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为 0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为 0，这被称为**零初始化**，还可对静态变量进行**常量表达式初始化**和**动态初始化**，零初始化和常量表达式初始化被统称为**静态初始化**，这意味着在编译器处理文件时初始化变量。动态初始化意味着变量将在编译后初始化

##### 变量声明
C++有单定义规则，即变量只能有一次定义，为满足这种需求，C++提供了两种变量声明
- **定义声明（defining declaration）**，会分配内存空间
  ```cpp
  int a;
  int b = 10;
  //这两句都分配了内存空间（定义），并声明了变量类型；
  ```
- **引用声明（referencing declaration）**，不会分配内存空间，它引用已有的变量，使用关键字 `extern`，且不会进行初始化
  ```cpp
  extern int a;
  ```

静态存储持续性有三种：

- **外部链接性**：在<u>源文件</u>的函数外部声明，对其他文件可见，如果要在其他文件中使用外部变量，需要用`extern`声明如
  ```cpp 
  // file a.cpp
  // 这两种方式都会具有外部链接性
  int globalVar1 = 1;
  //-----------------------------------

  // file a.h
  extern int globalVar1;
  //-----------------------------------

  // file 2 b.h
  // 包含头文件a.h即可使用
  #include "a.h"
  std::cout <<globalVar1;
  ```
- **内部链接性**：在<u>源文件</u>的函数外部声明，只对所在文件可见
  ```cpp
  // file a.cpp
  static int internalVar1;
  const int internalVar2; //const 全局变量的链接性为内部的。
  ```
- **无链接性**：在<u>源文件</u>的函数内部声明，，只对对所在函数可见，<u>不随函数结束就释放，即使函数不处于活动状态也存在</u>
  ```cpp
  // file a.cpp
  void fun(){
      static int Var;
  }
  ```

#### 线程存储持续性（C++11
生命周期与所属的线程一样长
- **thread_local**：可与 `static` 或 `extern` 结合使用如
  ```cpp
  thread_local static int myVar = 1;
  ```

#### 动态存储持续性(自由存储、堆)
用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。这种内存的存储持续性为动态
