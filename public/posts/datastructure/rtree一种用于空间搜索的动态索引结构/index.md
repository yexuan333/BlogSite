# 

# R树:一种用于空间搜索的动态索引结构
### R树属性
M 为一个节点的最大条目数
m<=M/2 为指定节点中最小条目数的参数
根节点(root node)
非叶子节点(non-leaf node)存放的是这些数据的“边界”，或者说索引
叶子节点（leaf node）存放的是真实存在的数据
### R树的基本性质
- 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。
- 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。
- 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。
- 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。
- R树为平衡树，所有叶子结点都位于同一层
  ![1683356092443](/assets/1683356092443.jpg)
#### Search
给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录
1. **搜索子树** 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search
2. **搜索叶子节点** 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。
#### Insertion
描述：将新的记录条目E插入给定的R树中。
1. **为新记录找到合适插入的叶子结点** 开始ChooseLeaf方法选择叶子结点L以放置记录E。
2. **添加新记录至叶子结点** 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。
3. **将变换向上传递** 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。
4. **对树进行增高操作** 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。
#### ChooseLeaf
描述：选择叶子结点以放置新条目E。
1. **Initialize** 设置N为根结点。
2. **叶子结点的检查** 如果N为叶子结点，则直接返回N。
3. **选择子树** 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。
4. **下降至叶子结点** 将N设为F，从CL2开始重复操作。
#### AdjustTree
描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。
1. **初始化** 将N设为L。
2. **检验是否完成** 如果N为根结点，则停止操作。
3. **调整父结点条目的最小边界矩形** 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。
4. **向上传递结点分裂** 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。
5. **升高至下一级** 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。
#### Delete
描述：将一条记录E从指定的R树中删除。
D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。
D2：[删除记录] 将E从L中删除。
D3：[传递记录] 对L使用CondenseTree操作
D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。
#### FindLeaf
描述：根结点为T，期望找到包含有记录E的叶子结点。
FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。
FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。
#### CondenseTree
描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。
CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。
CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。
CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。
CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。
CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。
### 节点分裂
为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的覆盖矩形是否与搜索区域重叠，所以分割后的两个覆盖矩形的总面积应该最小。下图说明了这一点。 “坏分割”情况下覆盖矩形的面积比“好分割”情况下的大得多。
![1683358779041](/assets/1683358779041.jpg)
下列是将 M+1 个条目的集合分成两组的算法：
- **穷举算法**
- **二次分裂** A Quadratic-Cost Algorithm
**会造成很多重叠区域**
该算法试图找到一个小面积的分割，但不能保证找到一个尽可能小的区域。成本在 M 中是二次方，在维数方面是线性的。该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。
- **线性分裂** A Linear-Cost Algorithm
**会造成更多的重叠区域，但是构建速度快一点**
该算法在 M 和维数方面是线性的。 Linear Split 与 Quadratic Split 仅区别在不同版本的PickSeeds。
1. **沿所有维度查找极端矩形** 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。
2. **调整矩形簇的形状** 通过沿相应维度除以整个集合的宽度来标准化分离。
3. **选择最极端的对** 选择沿任何维度具有最大归一化分离的对。

[从B树、B+树、B*树谈到R 树]https://blog.csdn.net/v_JULY_v/article/details/6530142/
https://blog.csdn.net/MongChia1993/article/details/69941783#toc_13
