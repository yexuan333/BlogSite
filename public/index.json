[{"categories":null,"content":"官方文档 中文文档 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/:0:0","series":["CMake"],"tags":null,"title":"CMake常见变量","uri":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/#"},{"categories":null,"content":"\r项目和版本信息 CMAKE_PROJECT_NAME: 项目名称。 PROJECT_NAME: 当前处理的项目名称。 PROJECT_VERSION, PROJECT_VERSION_MAJOR, PROJECT_VERSION_MINOR, PROJECT_VERSION_PATCH, PROJECT_VERSION_TWEAK: 项目的版本信息。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/:0:1","series":["CMake"],"tags":null,"title":"CMake常见变量","uri":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/#项目和版本信息"},{"categories":null,"content":"\r路径和目录 CMAKE_SOURCE_DIR: 顶级源代码目录的路径。 CMAKE_CURRENT_SOURCE_DIR: 当前处理的源代码目录的路径。 CMAKE_BINARY_DIR: 顶级构建目录的路径。 CMAKE_CURRENT_BINARY_DIR: 当前处理的构建目录的路径。 CMAKE_INSTALL_PREFIX: 安装路径前缀（默认是 /usr/local 或 C:/Program Files 等）。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/:0:2","series":["CMake"],"tags":null,"title":"CMake常见变量","uri":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/#路径和目录"},{"categories":null,"content":"\r编译器和工具设置 CMAKE_C_COMPILER: C编译器的路径。 CMAKE_CXX_COMPILER: C++编译器的路径。 CMAKE_BUILD_TYPE: 构建类型（如 Release 或 Debug）。 -CMAKE_C_FLAGS, CMAKE_CXX_FLAGS: C/C++编译器的特定标志。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/:0:3","series":["CMake"],"tags":null,"title":"CMake常见变量","uri":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/#编译器和工具设置"},{"categories":null,"content":"\r平台和系统信息 CMAKE_SYSTEM_NAME: 系统名称，例如 Linux、Windows。 CMAKE_SYSTEM_PROCESSOR: 处理器名称，例如 x86_64、AMD64。 WIN32, UNIX, APPLE: 特定平台的布尔变量。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/:0:4","series":["CMake"],"tags":null,"title":"CMake常见变量","uri":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/#平台和系统信息"},{"categories":null,"content":"\r安装和目录选项 CMAKE_INSTALL_BINDIR, CMAKE_INSTALL_LIBDIR, CMAKE_INSTALL_INCLUDEDIR: 用于安装二进制文件、库和头文件的目录。 CMAKE_MODULE_PATH: CMake模块查找路径。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/:0:5","series":["CMake"],"tags":null,"title":"CMake常见变量","uri":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/#安装和目录选项"},{"categories":null,"content":"\r功能和条件判断 BUILD_SHARED_LIBS: 是否构建共享库，而不是静态库。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/:0:6","series":["CMake"],"tags":null,"title":"CMake常见变量","uri":"/posts/cmake/cmake%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/#功能和条件判断"},{"categories":null,"content":"\r3. 安装官方install文档 cmake --install . 执行安装命令 cmake --install . --config Release 以Release模式安装 cmake --install . --prefix \"/home/myuser/installdir\" 指定安装根目录安装，也可以设置CMAKE_INSTALL_PREFIX变量实现 include(GNUInstallDirs)含义 # 提供一种跨平台的方式来处理安装路径，确保项目按照GNU的标准安装目录结构来安装。它在不同系统间提供了一致性，并使得项目更易于在不同Linux发行版上打包和分发。 安装目标的相关文件： install(TARGETS HelloWorld CONFIGURATIONS Release RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} PRIVATE_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_LIBDIR} HEADERS DESTINATION ${CMAKE_INSTALL_LIBDIR}) 安装文件，通过这种形式安装的文件默认具有权限设置，OWNER_WRITE（所有者写权限）、OWNER_READ（所有者读权限）、GROUP_READ（组读权限）和WORLD_READ（所有用户读权限），如果没有给出其他参数的话。 安装程序，与 FILES 形式相同，除了安装文件的默认权限还包括 OWNER_EXECUTE（所有者执行权限）、GROUP_EXECUTE（组执行权限）和 WORLD_EXECUTE（所有用户执行权限）。这种形式旨在安装非TARGETS目标程序，例如脚本文件。 必须提供TYPE或DESTINATION参数之一 TYPE参数指定了被安装文件的通用文件类型。然后，安装目标位置会通过从GNUInstallDirs中获取相应的变量自动设置，或者如果该变量未定义，则使用内置默认值。 DESTINATION可设置相对路径或绝对路径 install(\u003cFILES|PROGRAMS\u003e \u003cfile\u003e... TYPE \u003ctype\u003e | DESTINATION \u003cdir\u003e [PERMISSIONS \u003cpermission\u003e...] [CONFIGURATIONS \u003cconfig\u003e...] [COMPONENT \u003ccomponent\u003e] [RENAME \u003cname\u003e] [OPTIONAL] [EXCLUDE_FROM_ALL]) 安装目录 install(DIRECTORY dirs... TYPE \u003ctype\u003e | DESTINATION \u003cdir\u003e [FILE_PERMISSIONS \u003cpermission\u003e...] [DIRECTORY_PERMISSIONS \u003cpermission\u003e...] [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER] [CONFIGURATIONS \u003cconfig\u003e...] [COMPONENT \u003ccomponent\u003e] [EXCLUDE_FROM_ALL] [FILES_MATCHING] [[PATTERN \u003cpattern\u003e | REGEX \u003cregex\u003e] [EXCLUDE] [PERMISSIONS \u003cpermission\u003e...]] [...]) 安装脚本或代码，代码会被执行 install([[SCRIPT \u003cfile\u003e] [CODE \u003ccode\u003e]] [ALL_COMPONENTS | COMPONENT \u003ccomponent\u003e] [EXCLUDE_FROM_ALL] [...]) 安装一个 CMake 文件，为依赖项目导出目标： install(EXPORT \u003cexport-name\u003e DESTINATION \u003cdir\u003e [NAMESPACE \u003cnamespace\u003e] [FILE \u003cname\u003e.cmake] [PERMISSIONS \u003cpermission\u003e...] [CONFIGURATIONS \u003cconfig\u003e...] [CXX_MODULES_DIRECTORY \u003cdirectory\u003e] [EXPORT_LINK_INTERFACE_LIBRARIES] [COMPONENT \u003ccomponent\u003e] [EXCLUDE_FROM_ALL]) install(EXPORT_ANDROID_MK \u003cexport-name\u003e DESTINATION \u003cdir\u003e [...]) 安装运行时依赖项集： install(RUNTIME_DEPENDENCY_SET \u003cset-name\u003e [[LIBRARY|RUNTIME|FRAMEWORK] [DESTINATION \u003cdir\u003e] [PERMISSIONS \u003cpermission\u003e...] [CONFIGURATIONS \u003cconfig\u003e...] [COMPONENT \u003ccomponent\u003e] [NAMELINK_COMPONENT \u003ccomponent\u003e] [OPTIONAL] [EXCLUDE_FROM_ALL] ] [...] [PRE_INCLUDE_REGEXES \u003cregex\u003e...] [PRE_EXCLUDE_REGEXES \u003cregex\u003e...] [POST_INCLUDE_REGEXES \u003cregex\u003e...] [POST_EXCLUDE_REGEXES \u003cregex\u003e...] [POST_INCLUDE_FILES \u003cfile\u003e...] [POST_EXCLUDE_FILES \u003cfile\u003e...] [DIRECTORIES \u003cdir\u003e...] ) ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AE%89%E8%A3%85/:1:0","series":["CMake"],"tags":null,"title":"CMake导出与安装","uri":"/posts/cmake/cmake%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AE%89%E8%A3%85/#3-安装"},{"categories":null,"content":"\r4. 测试","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AE%89%E8%A3%85/:2:0","series":["CMake"],"tags":null,"title":"CMake导出与安装","uri":"/posts/cmake/cmake%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AE%89%E8%A3%85/#4-测试"},{"categories":null,"content":"\r5. 打包","date":"2023-12-24","objectID":"/posts/cmake/cmake%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AE%89%E8%A3%85/:3:0","series":["CMake"],"tags":null,"title":"CMake导出与安装","uri":"/posts/cmake/cmake%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AE%89%E8%A3%85/#5-打包"},{"categories":null,"content":"中文文档 Modern CMake文档 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/:0:0","series":["CMake"],"tags":null,"title":"CMake简介","uri":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/#"},{"categories":null,"content":"\rIntroduction to CMakeCMake 是一个开源的、跨平台的自动化构建系统，用于管理软件构建过程。它使用名为 CMakeLists.txt 的文件来描述构建过程，这使得它与传统的 Makefile 或项目文件不同。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/:1:0","series":["CMake"],"tags":null,"title":"CMake简介","uri":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/#introduction-to-cmake"},{"categories":null,"content":"\rWhat is CMakeCMake 不是一个构建工具，而是一个构建工具生成器。它可以为多种平台和工具生成标准的构建文件，如 Makefiles、Visual Studio 项目文件等。这意味着，开发者只需编写一次 CMake 脚本，就可以在多个平台上构建他们的项目。 CMake 的主要功能 (Main features of CMake) 跨平台：CMake 支持多种操作系统和编译器，如 Linux、Windows、macOS、GCC、Clang、Visual Studio 等。 灵活性：CMake 允许开发者为不同的平台和编译器指定不同的构建选项和设置。 模块化：CMake 有一个强大的模块系统，可以轻松地找到、使用和链接各种库。 可扩展性：开发者可以为 CMake 编写自己的模块和脚本，以满足特定的构建需求。 要使用 CMake 生成构建系统，必须选择以下内容： 源代码目录：包含项目提供的源文件的顶级目录。从名为 CMakeLists.txt 的顶级文件开始。这些文件指定构建目标及其依赖项 构建目录：要存储构建系统文件和构建输出工件（例如可执行文件和库）的顶级目录。 CMake 将编写一个 CMakeCache.txt 文件来将该目录标识为构建树并存储持久性信息，例如构建系统配置选项。 生成器：这选择了要生成的构建系统的种类。运行 cmake –help 查看本地可用的生成器列表。可以选择使用下面的 -G 选项来指定生成器。 ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/:1:1","series":["CMake"],"tags":null,"title":"CMake简介","uri":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/#what-is-cmake"},{"categories":null,"content":"\rRun CMake你始终应该建立一个专用于构建的目录并在那里构建项目。从技术上来讲，你可以进行内部构建（即在源代码目录下执行 CMake 构建命令），但是必须注意不要覆盖文件或者把它们添加到 git。 ~/package $ mkdir build ~/package $ cd build ~/package/build $ cmake .. ~/package/build $ make 以下任何一条命令都能够执行安装： # From the build directory (pick one) ~/package/build $ make install ~/package/build $ cmake --build . --target install ~/package/build $ cmake --install . # CMake 3.15+ only # From the source directory (pick one) ~/package $ make -C build install ~/package $ cmake --build build --target install ~/package $ cmake --install build # CMake 3.15+ only ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/:1:2","series":["CMake"],"tags":null,"title":"CMake简介","uri":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/#run-cmake"},{"categories":null,"content":"\rDo’s and Don’ts参考Effective Modern CMake ","date":"2023-12-24","objectID":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/:1:3","series":["CMake"],"tags":null,"title":"CMake简介","uri":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/#dos-and-donts"},{"categories":null,"content":"\r发行说明","date":"2023-12-24","objectID":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/:1:4","series":["CMake"],"tags":null,"title":"CMake简介","uri":"/posts/cmake/cmake%E7%AE%80%E4%BB%8B/#发行说明httpscmake-docreadthedocsiozh-cnlatestreleaseindexhtml"},{"categories":null,"content":"cmkae下载 cmake 官方教程 ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:0:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#"},{"categories":null,"content":"\r1. 变量与缓存\r1.1 本地变量声明一个本地 ( local ) 变量： set(MY_VARIABLE \"value\") 变量名通常全部用大写，变量值跟在其后。你可以通过 ${} 来解析一个变量，例如 ${MY_VARIABLE}, CMake 有作用域的概念，在声明一个变量后，你只可以在它的作用域内访问这个变量。如果你将一个函数或一个文件放到一个子目录中，这个变量将不再被定义。你可以通过在变量声明末尾添加 PARENT_SCOPE 来将它的作用域置定为当前的上一级作用域。 声明一个列表类型的变量,; 分隔变量和空格的作用是一样的： set(MY_LIST \"one\" \"two\") set(MY_LIST \"one;two\") 1.2 缓存变量CMake 提供了一个缓存变量来允许你从命令行或cmake-gui中设置变量, 这么写不会覆盖已定义的值 set(MY_CACHE_VARIABLE \"VALUE\" CACHE STRING \"Description\") 1.3 环境变量set(ENV{variable_name} value) 和 $ENV{variable_name} 来设置和获取环境变量 ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:1:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#1-变量与缓存"},{"categories":null,"content":"\r1. 变量与缓存\r1.1 本地变量声明一个本地 ( local ) 变量： set(MY_VARIABLE \"value\") 变量名通常全部用大写，变量值跟在其后。你可以通过 ${} 来解析一个变量，例如 ${MY_VARIABLE}, CMake 有作用域的概念，在声明一个变量后，你只可以在它的作用域内访问这个变量。如果你将一个函数或一个文件放到一个子目录中，这个变量将不再被定义。你可以通过在变量声明末尾添加 PARENT_SCOPE 来将它的作用域置定为当前的上一级作用域。 声明一个列表类型的变量,; 分隔变量和空格的作用是一样的： set(MY_LIST \"one\" \"two\") set(MY_LIST \"one;two\") 1.2 缓存变量CMake 提供了一个缓存变量来允许你从命令行或cmake-gui中设置变量, 这么写不会覆盖已定义的值 set(MY_CACHE_VARIABLE \"VALUE\" CACHE STRING \"Description\") 1.3 环境变量set(ENV{variable_name} value) 和 $ENV{variable_name} 来设置和获取环境变量 ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:1:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#11-本地变量"},{"categories":null,"content":"\r1. 变量与缓存\r1.1 本地变量声明一个本地 ( local ) 变量： set(MY_VARIABLE \"value\") 变量名通常全部用大写，变量值跟在其后。你可以通过 ${} 来解析一个变量，例如 ${MY_VARIABLE}, CMake 有作用域的概念，在声明一个变量后，你只可以在它的作用域内访问这个变量。如果你将一个函数或一个文件放到一个子目录中，这个变量将不再被定义。你可以通过在变量声明末尾添加 PARENT_SCOPE 来将它的作用域置定为当前的上一级作用域。 声明一个列表类型的变量,; 分隔变量和空格的作用是一样的： set(MY_LIST \"one\" \"two\") set(MY_LIST \"one;two\") 1.2 缓存变量CMake 提供了一个缓存变量来允许你从命令行或cmake-gui中设置变量, 这么写不会覆盖已定义的值 set(MY_CACHE_VARIABLE \"VALUE\" CACHE STRING \"Description\") 1.3 环境变量set(ENV{variable_name} value) 和 $ENV{variable_name} 来设置和获取环境变量 ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:1:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#12-缓存变量"},{"categories":null,"content":"\r1. 变量与缓存\r1.1 本地变量声明一个本地 ( local ) 变量： set(MY_VARIABLE \"value\") 变量名通常全部用大写，变量值跟在其后。你可以通过 ${} 来解析一个变量，例如 ${MY_VARIABLE}, CMake 有作用域的概念，在声明一个变量后，你只可以在它的作用域内访问这个变量。如果你将一个函数或一个文件放到一个子目录中，这个变量将不再被定义。你可以通过在变量声明末尾添加 PARENT_SCOPE 来将它的作用域置定为当前的上一级作用域。 声明一个列表类型的变量,; 分隔变量和空格的作用是一样的： set(MY_LIST \"one\" \"two\") set(MY_LIST \"one;two\") 1.2 缓存变量CMake 提供了一个缓存变量来允许你从命令行或cmake-gui中设置变量, 这么写不会覆盖已定义的值 set(MY_CACHE_VARIABLE \"VALUE\" CACHE STRING \"Description\") 1.3 环境变量set(ENV{variable_name} value) 和 $ENV{variable_name} 来设置和获取环境变量 ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:1:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#13-环境变量"},{"categories":null,"content":"\r2. 缓存缓存实际上就是个文本文件，CMakeCache.txt ，当你运行 CMake 构建目录时会创建它。 CMake 可以通过它来记住你设置的所有东西，因此你可以不必在重新运行 CMake 的时候再次列出所有的选项。 ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:2:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#2-缓存"},{"categories":null,"content":"\r3. 简单的例子 cmake_minimum_required(VERSION 3.1...3.21) # This is your project statement. You should always list languages; # Listing the version is nice here since it sets lots of useful variables project( CMakeExample VERSION 1.0 LANGUAGES CXX) # Find packages go here. # You should usually split this into folders, but this is a simple example # This is a \"default\" library add_library(MyLibExample simple_lib.cpp simple_lib.hpp) # Link each target with other targets or add options, etc. # Adding something we can run - Output name matches target name add_executable(MyExample simple_example.cpp) target_link_libraries(MyExample PRIVATE MyLibExample) set(CMAKE_CXX_STANDARD 11) 启用对特定 C++ 标准的支持 set(CMAKE_CXX_STANDARD_REQUIRED True) 确保标准的可用性，如果指定的标准不可用，CMake配置过程将失败。 project(HelloWorld VERSION 1.2.3) 设置项目版本号 在设置了版本号之后，CMake会提供一些变量来代表这些值： PROJECT_VERSION - 完整的版本号，例如 “1.2.3”。 PROJECT_VERSION_MAJOR - 主版本号，例如 “1”。 PROJECT_VERSION_MINOR - 副版本号，例如 “2”。 PROJECT_VERSION_PATCH - 补丁版本号，例如 “3”。 target_precompile_headers添加要预编译的头文件列表。 target_sources将源添加到目标。 3.1 创建库或可执行文件add_library add_library(\u003cname\u003e [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [\u003csource\u003e...]) 使用指定的源文件将库添加到项目中。 STATIC 库是目标文件的存档，供链接其他目标时使用，生成.lib（Windows）.a（Unix） SHARED 库动态链接并在运行时加载，生成.dll（Windows）.so（Unix） MODULE 库是不链接到其他目标但可以在运行时通过程序的某种形式动态加载的库 add_library(\u003cname\u003e ALIAS \u003ctarget\u003e)别名库 add_executable add_executable(\u003cname\u003e [EXCLUDE_FROM_ALL] [\u003csource\u003e...]) 使用指定的源文件向项目添加可执行文件。 在 3.11 版本加入: 如果稍后使用 target_sources() 添加源文件，则可以省略加入源文件。 add_executable(\u003cname\u003e IMPORTED [GLOBAL])导入可执行文件，后续可在add_custom_command() 等命令中引用 add_executable(\u003cname\u003e ALIAS \u003ctarget\u003e)别名可执行文件 3.2 添加库target_XXX和XXX的区别 target_XXX 指定给定目标，且指定的 target 必须由命令创建，例如 add_executable() 或 add_library() 并且不能是 ALIAS target。 XXX 会影响该文件及其子目录中定义的所有目标（包括可执行文件和库）（不会向上传播） 传递选项 PRIVATE，仅被定义目标需要，并且不会传递给依赖该目标的其他目标。 PUBLIC，链接库对定义目标和依赖该目标的其他目标都是可见的。 INTERFACE，用于当你不需要将库链接到当前目标，但希望将链接要求传递给依赖该目标的其他目标。这仅适用于库的接口（如头文件路径、编译定义等） 链接库 include_directories``target_include_directories 将包含目录添加到目标。 link_libraries``target_link_libraries指定链接给定目标和/或其依赖项时要使用的库或标志。 link_directories``target_link_directories将链接目录添加到目标。 add_compile_definitions``target_compile_definitions 将编译定义添加到目标。 项目上任何前导的 -D 都将被删除。空项将被忽略。例如，以下都是等价的： target_compile_definitions(foo PUBLIC FOO) target_compile_definitions(foo PUBLIC -DFOO) # -D removed target_compile_definitions(foo PUBLIC \"\" FOO) # \"\" ignored target_compile_definitions(foo PUBLIC -D FOO) # -D becomes \"\", then ignored ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:3:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#3-简单的例子"},{"categories":null,"content":"\r3. 简单的例子 cmake_minimum_required(VERSION 3.1...3.21) # This is your project statement. You should always list languages; # Listing the version is nice here since it sets lots of useful variables project( CMakeExample VERSION 1.0 LANGUAGES CXX) # Find packages go here. # You should usually split this into folders, but this is a simple example # This is a \"default\" library add_library(MyLibExample simple_lib.cpp simple_lib.hpp) # Link each target with other targets or add options, etc. # Adding something we can run - Output name matches target name add_executable(MyExample simple_example.cpp) target_link_libraries(MyExample PRIVATE MyLibExample) set(CMAKE_CXX_STANDARD 11) 启用对特定 C++ 标准的支持 set(CMAKE_CXX_STANDARD_REQUIRED True) 确保标准的可用性，如果指定的标准不可用，CMake配置过程将失败。 project(HelloWorld VERSION 1.2.3) 设置项目版本号 在设置了版本号之后，CMake会提供一些变量来代表这些值： PROJECT_VERSION - 完整的版本号，例如 “1.2.3”。 PROJECT_VERSION_MAJOR - 主版本号，例如 “1”。 PROJECT_VERSION_MINOR - 副版本号，例如 “2”。 PROJECT_VERSION_PATCH - 补丁版本号，例如 “3”。 target_precompile_headers添加要预编译的头文件列表。 target_sources将源添加到目标。 3.1 创建库或可执行文件add_library add_library( [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [...]) 使用指定的源文件将库添加到项目中。 STATIC 库是目标文件的存档，供链接其他目标时使用，生成.lib（Windows）.a（Unix） SHARED 库动态链接并在运行时加载，生成.dll（Windows）.so（Unix） MODULE 库是不链接到其他目标但可以在运行时通过程序的某种形式动态加载的库 add_library( ALIAS )别名库 add_executable add_executable( [EXCLUDE_FROM_ALL] [...]) 使用指定的源文件向项目添加可执行文件。 在 3.11 版本加入: 如果稍后使用 target_sources() 添加源文件，则可以省略加入源文件。 add_executable( IMPORTED [GLOBAL])导入可执行文件，后续可在add_custom_command() 等命令中引用 add_executable( ALIAS )别名可执行文件 3.2 添加库target_XXX和XXX的区别 target_XXX 指定给定目标，且指定的 target 必须由命令创建，例如 add_executable() 或 add_library() 并且不能是 ALIAS target。 XXX 会影响该文件及其子目录中定义的所有目标（包括可执行文件和库）（不会向上传播） 传递选项 PRIVATE，仅被定义目标需要，并且不会传递给依赖该目标的其他目标。 PUBLIC，链接库对定义目标和依赖该目标的其他目标都是可见的。 INTERFACE，用于当你不需要将库链接到当前目标，但希望将链接要求传递给依赖该目标的其他目标。这仅适用于库的接口（如头文件路径、编译定义等） 链接库 include_directories``target_include_directories 将包含目录添加到目标。 link_libraries``target_link_libraries指定链接给定目标和/或其依赖项时要使用的库或标志。 link_directories``target_link_directories将链接目录添加到目标。 add_compile_definitions``target_compile_definitions 将编译定义添加到目标。 项目上任何前导的 -D 都将被删除。空项将被忽略。例如，以下都是等价的： target_compile_definitions(foo PUBLIC FOO) target_compile_definitions(foo PUBLIC -DFOO) # -D removed target_compile_definitions(foo PUBLIC \"\" FOO) # \"\" ignored target_compile_definitions(foo PUBLIC -D FOO) # -D becomes \"\", then ignored ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:3:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#31-创建库或可执行文件"},{"categories":null,"content":"\r3. 简单的例子 cmake_minimum_required(VERSION 3.1...3.21) # This is your project statement. You should always list languages; # Listing the version is nice here since it sets lots of useful variables project( CMakeExample VERSION 1.0 LANGUAGES CXX) # Find packages go here. # You should usually split this into folders, but this is a simple example # This is a \"default\" library add_library(MyLibExample simple_lib.cpp simple_lib.hpp) # Link each target with other targets or add options, etc. # Adding something we can run - Output name matches target name add_executable(MyExample simple_example.cpp) target_link_libraries(MyExample PRIVATE MyLibExample) set(CMAKE_CXX_STANDARD 11) 启用对特定 C++ 标准的支持 set(CMAKE_CXX_STANDARD_REQUIRED True) 确保标准的可用性，如果指定的标准不可用，CMake配置过程将失败。 project(HelloWorld VERSION 1.2.3) 设置项目版本号 在设置了版本号之后，CMake会提供一些变量来代表这些值： PROJECT_VERSION - 完整的版本号，例如 “1.2.3”。 PROJECT_VERSION_MAJOR - 主版本号，例如 “1”。 PROJECT_VERSION_MINOR - 副版本号，例如 “2”。 PROJECT_VERSION_PATCH - 补丁版本号，例如 “3”。 target_precompile_headers添加要预编译的头文件列表。 target_sources将源添加到目标。 3.1 创建库或可执行文件add_library add_library( [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [...]) 使用指定的源文件将库添加到项目中。 STATIC 库是目标文件的存档，供链接其他目标时使用，生成.lib（Windows）.a（Unix） SHARED 库动态链接并在运行时加载，生成.dll（Windows）.so（Unix） MODULE 库是不链接到其他目标但可以在运行时通过程序的某种形式动态加载的库 add_library( ALIAS )别名库 add_executable add_executable( [EXCLUDE_FROM_ALL] [...]) 使用指定的源文件向项目添加可执行文件。 在 3.11 版本加入: 如果稍后使用 target_sources() 添加源文件，则可以省略加入源文件。 add_executable( IMPORTED [GLOBAL])导入可执行文件，后续可在add_custom_command() 等命令中引用 add_executable( ALIAS )别名可执行文件 3.2 添加库target_XXX和XXX的区别 target_XXX 指定给定目标，且指定的 target 必须由命令创建，例如 add_executable() 或 add_library() 并且不能是 ALIAS target。 XXX 会影响该文件及其子目录中定义的所有目标（包括可执行文件和库）（不会向上传播） 传递选项 PRIVATE，仅被定义目标需要，并且不会传递给依赖该目标的其他目标。 PUBLIC，链接库对定义目标和依赖该目标的其他目标都是可见的。 INTERFACE，用于当你不需要将库链接到当前目标，但希望将链接要求传递给依赖该目标的其他目标。这仅适用于库的接口（如头文件路径、编译定义等） 链接库 include_directories``target_include_directories 将包含目录添加到目标。 link_libraries``target_link_libraries指定链接给定目标和/或其依赖项时要使用的库或标志。 link_directories``target_link_directories将链接目录添加到目标。 add_compile_definitions``target_compile_definitions 将编译定义添加到目标。 项目上任何前导的 -D 都将被删除。空项将被忽略。例如，以下都是等价的： target_compile_definitions(foo PUBLIC FOO) target_compile_definitions(foo PUBLIC -DFOO) # -D removed target_compile_definitions(foo PUBLIC \"\" FOO) # \"\" ignored target_compile_definitions(foo PUBLIC -D FOO) # -D becomes \"\", then ignored ","date":"2023-12-23","objectID":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/:3:0","series":["CMake"],"tags":null,"title":"CMake基础","uri":"/posts/cmake/cmake%E5%9F%BA%E7%A1%80/#32-添加库"},{"categories":null,"content":"一组点的凸包是最小的凸集的点。凸包是数学和计算几何的基本结构。 例如，Boardman [1993] 在光谱数据分析中使用了凸包，而Weeks [1991] 则利用凸包来确定有尖端的双曲3-流形的规范三角剖分。其他问题可以归结为凸包问题——例如，半空间交集、Delaunay三角剖分、Voronoi图和幂图。Aurenhammer [1991] 在其综述文章中描述了这些结构在网格生成、文件搜索、聚类分析、碰撞检测、晶体学、冶金学、城市规划、制图学、图像处理、数值积分、统计学、球形包装和点定位中的应用。 提出并分析了一种处理点的更有效策略，以便于处理有内部点的分布。结果是一个对于具有内部点的分布来说更快的算法。 ","date":"2023-12-17","objectID":"/posts/geoalgo/convexhull3d_quick/:0:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Quick","uri":"/posts/geoalgo/convexhull3d_quick/#"},{"categories":null,"content":"\r简介三维凸包增量法是一种用于构建三维凸包的有效算法，它基于不断添加新的点来逐步构建凸包。 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:1:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#简介"},{"categories":null,"content":"\r算法重点 新增点 假设$p_n$在当前凸包外，从$p_n$向凸包望去，可见的小平面组成了一条地平线$horizon$,只需将可见的小平面全部删掉，然后用$p_n$依次与$horizon$连接成新的小平面 通过冲突信息加速遍历 对于凸包中的每一个小平面$f$维护一个集合$f_{conflict}$,这个集合包含小平面$f$的可见点信息 对于每一个点$p_n$也要维护一个集合$p_{conflict}$，这个集合包含点$p_n$的可见面信息 下图$e$为$horizon$，$f_2$为要删除的小平面，$f$为新增面，$p_r$为新增点，而$f$的可见点的信息一定为$f_2$的可见点的信息和$f_1$的可见点的信息的并集的子集 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:2:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#算法重点"},{"categories":null,"content":"\r算法步骤输入：三维空间中n个点构成的集合 P 1. 构建四面体 从点集中选取四个点构成四面体（双向链接边表结构） 2. 构建冲突信息 遍历剩余的点 为四面体的每个面添加可见点的index 为每个点添加可见面的index 3. 循环添加剩余点$P_n$ 如果点$P_n$有可见面 将所有可见面删除 遍历所有可见面的边 如果该边的TwinEdge的Face未被删除，则该TwinEdge为$horizons$之一 对$horizons$进行排序，使其首位对应 遍历$horizons$ 以Horizon的TwinEdge创建新面NewFace，记Horizon的TwinEdge原先的RemovedFace,Horizon的NeighbourFace Horizon的face与$P_n$共面 删除NewFace，将Horizon的face合并NewFace Horizon的face与$P_n$不共面 初始NewFace的冲突信息为NeighbourFace和RemovedFace的并集 遍历NewFace的冲突信息去除看不到的点，并更新剩余点的冲突信息 4. 完成凸包 返回双向链接边表 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:3:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#算法步骤"},{"categories":null,"content":"\r算法步骤输入：三维空间中n个点构成的集合 P 1. 构建四面体 从点集中选取四个点构成四面体（双向链接边表结构） 2. 构建冲突信息 遍历剩余的点 为四面体的每个面添加可见点的index 为每个点添加可见面的index 3. 循环添加剩余点$P_n$ 如果点$P_n$有可见面 将所有可见面删除 遍历所有可见面的边 如果该边的TwinEdge的Face未被删除，则该TwinEdge为$horizons$之一 对$horizons$进行排序，使其首位对应 遍历$horizons$ 以Horizon的TwinEdge创建新面NewFace，记Horizon的TwinEdge原先的RemovedFace,Horizon的NeighbourFace Horizon的face与$P_n$共面 删除NewFace，将Horizon的face合并NewFace Horizon的face与$P_n$不共面 初始NewFace的冲突信息为NeighbourFace和RemovedFace的并集 遍历NewFace的冲突信息去除看不到的点，并更新剩余点的冲突信息 4. 完成凸包 返回双向链接边表 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:3:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#1-构建四面体"},{"categories":null,"content":"\r算法步骤输入：三维空间中n个点构成的集合 P 1. 构建四面体 从点集中选取四个点构成四面体（双向链接边表结构） 2. 构建冲突信息 遍历剩余的点 为四面体的每个面添加可见点的index 为每个点添加可见面的index 3. 循环添加剩余点$P_n$ 如果点$P_n$有可见面 将所有可见面删除 遍历所有可见面的边 如果该边的TwinEdge的Face未被删除，则该TwinEdge为$horizons$之一 对$horizons$进行排序，使其首位对应 遍历$horizons$ 以Horizon的TwinEdge创建新面NewFace，记Horizon的TwinEdge原先的RemovedFace,Horizon的NeighbourFace Horizon的face与$P_n$共面 删除NewFace，将Horizon的face合并NewFace Horizon的face与$P_n$不共面 初始NewFace的冲突信息为NeighbourFace和RemovedFace的并集 遍历NewFace的冲突信息去除看不到的点，并更新剩余点的冲突信息 4. 完成凸包 返回双向链接边表 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:3:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#2-构建冲突信息"},{"categories":null,"content":"\r算法步骤输入：三维空间中n个点构成的集合 P 1. 构建四面体 从点集中选取四个点构成四面体（双向链接边表结构） 2. 构建冲突信息 遍历剩余的点 为四面体的每个面添加可见点的index 为每个点添加可见面的index 3. 循环添加剩余点$P_n$ 如果点$P_n$有可见面 将所有可见面删除 遍历所有可见面的边 如果该边的TwinEdge的Face未被删除，则该TwinEdge为$horizons$之一 对$horizons$进行排序，使其首位对应 遍历$horizons$ 以Horizon的TwinEdge创建新面NewFace，记Horizon的TwinEdge原先的RemovedFace,Horizon的NeighbourFace Horizon的face与$P_n$共面 删除NewFace，将Horizon的face合并NewFace Horizon的face与$P_n$不共面 初始NewFace的冲突信息为NeighbourFace和RemovedFace的并集 遍历NewFace的冲突信息去除看不到的点，并更新剩余点的冲突信息 4. 完成凸包 返回双向链接边表 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:3:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#3-循环添加剩余点p_n"},{"categories":null,"content":"\r算法步骤输入：三维空间中n个点构成的集合 P 1. 构建四面体 从点集中选取四个点构成四面体（双向链接边表结构） 2. 构建冲突信息 遍历剩余的点 为四面体的每个面添加可见点的index 为每个点添加可见面的index 3. 循环添加剩余点$P_n$ 如果点$P_n$有可见面 将所有可见面删除 遍历所有可见面的边 如果该边的TwinEdge的Face未被删除，则该TwinEdge为$horizons$之一 对$horizons$进行排序，使其首位对应 遍历$horizons$ 以Horizon的TwinEdge创建新面NewFace，记Horizon的TwinEdge原先的RemovedFace,Horizon的NeighbourFace Horizon的face与$P_n$共面 删除NewFace，将Horizon的face合并NewFace Horizon的face与$P_n$不共面 初始NewFace的冲突信息为NeighbourFace和RemovedFace的并集 遍历NewFace的冲突信息去除看不到的点，并更新剩余点的冲突信息 4. 完成凸包 返回双向链接边表 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:3:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#4-完成凸包"},{"categories":null,"content":"\r优点动态更新： 该算法是在线算法，可以处理数据集动态变化的情况。在数据集不断更新时，可以仅考虑新加入的点，而不需要重新计算整个凸包。 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:4:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#优点"},{"categories":null,"content":"\r参考文献[1]计算几何算法与应用:第3版.第11章.邓俊辉译 ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:5:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#参考文献"},{"categories":null,"content":"\r项目链接https://github.com/yexuan333/GeoAlgoVisual ","date":"2023-12-10","objectID":"/posts/geoalgo/convexhull3d_incremental/:6:0","series":["计算几何"],"tags":null,"title":"ConvexHull3D Incremental","uri":"/posts/geoalgo/convexhull3d_incremental/#项目链接"},{"categories":null,"content":"\r简介Graham Scan算法是一种有效计算凸包的方法。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:1:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#简介"},{"categories":null,"content":"\r算法步骤\r1. 找到基准点 从点集中选取最低（或最高）Y坐标的点。 如果有多个点具有相同的Y坐标，则选择X坐标最小（或最大）的点作为基准点。 2. 排序 按照每个点相对于基准点的极角进行排序。 3. 创建凸包 初始化栈，将基准点和排序后的前两个点放入栈中。 遍历排序后的其他点，对于每个点执行以下操作： 当栈顶的两个点与当前点不构成“右转”时，从栈中弹出顶部点。 将当前点压入栈。 4. 完成凸包 遍历结束后，栈中剩余的点即构成凸包的顶点。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:2:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#算法步骤"},{"categories":null,"content":"\r算法步骤\r1. 找到基准点 从点集中选取最低（或最高）Y坐标的点。 如果有多个点具有相同的Y坐标，则选择X坐标最小（或最大）的点作为基准点。 2. 排序 按照每个点相对于基准点的极角进行排序。 3. 创建凸包 初始化栈，将基准点和排序后的前两个点放入栈中。 遍历排序后的其他点，对于每个点执行以下操作： 当栈顶的两个点与当前点不构成“右转”时，从栈中弹出顶部点。 将当前点压入栈。 4. 完成凸包 遍历结束后，栈中剩余的点即构成凸包的顶点。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:2:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#1-找到基准点"},{"categories":null,"content":"\r算法步骤\r1. 找到基准点 从点集中选取最低（或最高）Y坐标的点。 如果有多个点具有相同的Y坐标，则选择X坐标最小（或最大）的点作为基准点。 2. 排序 按照每个点相对于基准点的极角进行排序。 3. 创建凸包 初始化栈，将基准点和排序后的前两个点放入栈中。 遍历排序后的其他点，对于每个点执行以下操作： 当栈顶的两个点与当前点不构成“右转”时，从栈中弹出顶部点。 将当前点压入栈。 4. 完成凸包 遍历结束后，栈中剩余的点即构成凸包的顶点。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:2:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#2-排序"},{"categories":null,"content":"\r算法步骤\r1. 找到基准点 从点集中选取最低（或最高）Y坐标的点。 如果有多个点具有相同的Y坐标，则选择X坐标最小（或最大）的点作为基准点。 2. 排序 按照每个点相对于基准点的极角进行排序。 3. 创建凸包 初始化栈，将基准点和排序后的前两个点放入栈中。 遍历排序后的其他点，对于每个点执行以下操作： 当栈顶的两个点与当前点不构成“右转”时，从栈中弹出顶部点。 将当前点压入栈。 4. 完成凸包 遍历结束后，栈中剩余的点即构成凸包的顶点。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:2:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#3-创建凸包"},{"categories":null,"content":"\r算法步骤\r1. 找到基准点 从点集中选取最低（或最高）Y坐标的点。 如果有多个点具有相同的Y坐标，则选择X坐标最小（或最大）的点作为基准点。 2. 排序 按照每个点相对于基准点的极角进行排序。 3. 创建凸包 初始化栈，将基准点和排序后的前两个点放入栈中。 遍历排序后的其他点，对于每个点执行以下操作： 当栈顶的两个点与当前点不构成“右转”时，从栈中弹出顶部点。 将当前点压入栈。 4. 完成凸包 遍历结束后，栈中剩余的点即构成凸包的顶点。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:2:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#4-完成凸包"},{"categories":null,"content":"\r优点 效率高：时间复杂度为O(n log n)，主要耗时在于排序步骤。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:3:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#优点"},{"categories":null,"content":"\r缺点 不适用于动态点集：对于频繁变动的点集，需要重新计算整个凸包。 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:4:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#缺点"},{"categories":null,"content":"\r参考文献[1]计算几何算法与应用:第3版.第1章.邓俊辉译 ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:5:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#参考文献"},{"categories":null,"content":"\r项目链接https://github.com/yexuan333/GeoAlgoVisual ","date":"2023-11-27","objectID":"/posts/geoalgo/convexhull2d_grahamscan/:6:0","series":["计算几何"],"tags":null,"title":"ConvexHull2D GrahamScan","uri":"/posts/geoalgo/convexhull2d_grahamscan/#项目链接"},{"categories":null,"content":"\rRTree","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:0","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#rtree"},{"categories":null,"content":"\r背景RTree 是一种用于多维数据查询和存储的树形数据结构，最早由 Antonin Guttman 在 1984 年提出R-TREES: A DYNAMIC INDEX STRUCTURE FOR SPATIAL SEARCHING。在RTree中，“R\"代表\"rectangle”，即矩形。它将空间中的数据对象表示为矩形，使用这些矩形构建一棵树形结构以支持高效的空间查询操作。每个矩形代表一个数据对象，它的边界是该对象在空间中的边界。因此，RTree是一种基于矩形的数据结构，它的设计旨在使得空间查询操作的效率尽可能高。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:1","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#背景"},{"categories":null,"content":"\r基本属性\r节点（Non Leaf Node ）：RTree 的基本单元，保存的数据形式为：(I, child-pointer) I是覆盖所有子结点对应矩形的矩形 child-pointer是指向孩子结点的指针 边界矩形（MBR，Minimum Bounding Rectangle）：通常，我们不选择去索引几何物体本身，而是采用最小限定箱MBB作为不规则几何图形的key来构建空间索引。 在二维的情况下，我们称之为MBR(minimum bounding retangle) 三维的情况下，我们称MBB(minimum bounding box) 根节点（Root Node）：RTree 中最顶层的节点，不包含任何父节点。 叶节点（Leaf Node）：包含数据的节点，位于树的最底层。所保存的数据形式为：(I, tuple-identifier) I：一个n维空间的矩形，恰好可以框住这个叶子结点中所代表的数据 tuple-identifier：包含各种条目 条目（Entry）：包含MBR的最基础的数据 深度（Depth）：从根节点到叶节点的最长路径。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:2","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#基本属性"},{"categories":null,"content":"\r基本性质 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:3","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#基本性质"},{"categories":null,"content":"\r算法介绍\rSearch给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个子节点的MBR 是否与 S 重叠。对于所有重叠的节点，在该节点上调用 Search 搜索叶子节点 如果 T 是叶子结点，并且T的MBR与 S 重叠。则 T 是合格记录。 Insertion描述：将新的条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E,设置N为根结点 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 SplitNode为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的MBR是否与搜索区域重叠，所以分割后的两个MBR的总面积应该最小。下图说明了这一点。 “坏分割”情况下MBR的面积比“好分割”情况下的大得多。 在进行节点分裂之前先了解一些变量 $S_{Extend}$：$S_{覆盖条目后的MBR} - S_{覆盖条目前的MBR}$，例如下图，假设叶子节点有一个条目A,现在加入条目B后的扩张面积为下图的绿色部分 $S_{ExtendDiff}$：$|A_{S_{Extend}} - B_{S_{Extend}}|$, 假设有两个叶子节点A、B分别包含一个条目，现在分别计算加入条目c的扩张面积$A_{S_{Extend}}$和$B_{S_{Extend}}$,然后便计算可得 下列是将 M+1 个条目的集合分成两组的算法：以下图为例：红色矩形是一个叶子节点，红色小正方形是叶子节点内的9个条目，目前叶子节点的条目数量已经满了，现在要插入这个绿色的条目到这个叶子节点中 穷举算法 把所有的分裂的可能都尝试一遍，复杂度太高就不介绍了 二次分裂 A Quadratic-Cost Algorithm 该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。这个分裂方式会造成很多重叠区域，以下是计算步骤 PickSeeds 先选择两个节点到分裂后的节点中去，计算每两个条目合并后的扩张面积，找到扩张面积最大的两个条目 图一中每个线段代表着两两配对计算一次扩张面积 图二的绿色部分为计算后，最大的扩张面积的两个条目 1. **ChoosePartition** 根据所得到的两个条目，新建两个叶子节点，然后开始分割，对剩余的每个条目计算AB两个节点的$S_{ExtendDiff}$，选择$S_{ExtendDiff}$最大的条目，加入到对应的节点中，然后重复上述过程，在下图的最后一步中，为保证分裂后的子节点数量合法，所以会把剩余的节点全给另一个\r线性分裂 A Linear-Cost Algorithm 与 Quadratic Split 仅区别在不同版本的PickSeeds。并且会造成更多的重叠区域，但是构建速度快一点 沿所有维度查找极端矩形 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。 调整矩形簇的形状 通过沿相应维度除以整个集合的宽度来标准化分离。 选择最极端的对 选择沿任何维度具有最大归一化分离的对。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:4","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#算法介绍"},{"categories":null,"content":"\r算法介绍\rSearch给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个子节点的MBR 是否与 S 重叠。对于所有重叠的节点，在该节点上调用 Search 搜索叶子节点 如果 T 是叶子结点，并且T的MBR与 S 重叠。则 T 是合格记录。 Insertion描述：将新的条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E,设置N为根结点 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 SplitNode为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的MBR是否与搜索区域重叠，所以分割后的两个MBR的总面积应该最小。下图说明了这一点。 “坏分割”情况下MBR的面积比“好分割”情况下的大得多。 在进行节点分裂之前先了解一些变量 $S_{Extend}$：$S_{覆盖条目后的MBR} - S_{覆盖条目前的MBR}$，例如下图，假设叶子节点有一个条目A,现在加入条目B后的扩张面积为下图的绿色部分 $S_{ExtendDiff}$：$|A_{S_{Extend}} - B_{S_{Extend}}|$, 假设有两个叶子节点A、B分别包含一个条目，现在分别计算加入条目c的扩张面积$A_{S_{Extend}}$和$B_{S_{Extend}}$,然后便计算可得 下列是将 M+1 个条目的集合分成两组的算法：以下图为例：红色矩形是一个叶子节点，红色小正方形是叶子节点内的9个条目，目前叶子节点的条目数量已经满了，现在要插入这个绿色的条目到这个叶子节点中 穷举算法 把所有的分裂的可能都尝试一遍，复杂度太高就不介绍了 二次分裂 A Quadratic-Cost Algorithm 该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。这个分裂方式会造成很多重叠区域，以下是计算步骤 PickSeeds 先选择两个节点到分裂后的节点中去，计算每两个条目合并后的扩张面积，找到扩张面积最大的两个条目 图一中每个线段代表着两两配对计算一次扩张面积 图二的绿色部分为计算后，最大的扩张面积的两个条目 1. **ChoosePartition** 根据所得到的两个条目，新建两个叶子节点，然后开始分割，对剩余的每个条目计算AB两个节点的$S_{ExtendDiff}$，选择$S_{ExtendDiff}$最大的条目，加入到对应的节点中，然后重复上述过程，在下图的最后一步中，为保证分裂后的子节点数量合法，所以会把剩余的节点全给另一个\r线性分裂 A Linear-Cost Algorithm 与 Quadratic Split 仅区别在不同版本的PickSeeds。并且会造成更多的重叠区域，但是构建速度快一点 沿所有维度查找极端矩形 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。 调整矩形簇的形状 通过沿相应维度除以整个集合的宽度来标准化分离。 选择最极端的对 选择沿任何维度具有最大归一化分离的对。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:4","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#search"},{"categories":null,"content":"\r算法介绍\rSearch给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个子节点的MBR 是否与 S 重叠。对于所有重叠的节点，在该节点上调用 Search 搜索叶子节点 如果 T 是叶子结点，并且T的MBR与 S 重叠。则 T 是合格记录。 Insertion描述：将新的条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E,设置N为根结点 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 SplitNode为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的MBR是否与搜索区域重叠，所以分割后的两个MBR的总面积应该最小。下图说明了这一点。 “坏分割”情况下MBR的面积比“好分割”情况下的大得多。 在进行节点分裂之前先了解一些变量 $S_{Extend}$：$S_{覆盖条目后的MBR} - S_{覆盖条目前的MBR}$，例如下图，假设叶子节点有一个条目A,现在加入条目B后的扩张面积为下图的绿色部分 $S_{ExtendDiff}$：$|A_{S_{Extend}} - B_{S_{Extend}}|$, 假设有两个叶子节点A、B分别包含一个条目，现在分别计算加入条目c的扩张面积$A_{S_{Extend}}$和$B_{S_{Extend}}$,然后便计算可得 下列是将 M+1 个条目的集合分成两组的算法：以下图为例：红色矩形是一个叶子节点，红色小正方形是叶子节点内的9个条目，目前叶子节点的条目数量已经满了，现在要插入这个绿色的条目到这个叶子节点中 穷举算法 把所有的分裂的可能都尝试一遍，复杂度太高就不介绍了 二次分裂 A Quadratic-Cost Algorithm 该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。这个分裂方式会造成很多重叠区域，以下是计算步骤 PickSeeds 先选择两个节点到分裂后的节点中去，计算每两个条目合并后的扩张面积，找到扩张面积最大的两个条目 图一中每个线段代表着两两配对计算一次扩张面积 图二的绿色部分为计算后，最大的扩张面积的两个条目 1. **ChoosePartition** 根据所得到的两个条目，新建两个叶子节点，然后开始分割，对剩余的每个条目计算AB两个节点的$S_{ExtendDiff}$，选择$S_{ExtendDiff}$最大的条目，加入到对应的节点中，然后重复上述过程，在下图的最后一步中，为保证分裂后的子节点数量合法，所以会把剩余的节点全给另一个\r线性分裂 A Linear-Cost Algorithm 与 Quadratic Split 仅区别在不同版本的PickSeeds。并且会造成更多的重叠区域，但是构建速度快一点 沿所有维度查找极端矩形 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。 调整矩形簇的形状 通过沿相应维度除以整个集合的宽度来标准化分离。 选择最极端的对 选择沿任何维度具有最大归一化分离的对。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:4","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#insertion"},{"categories":null,"content":"\r算法介绍\rSearch给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个子节点的MBR 是否与 S 重叠。对于所有重叠的节点，在该节点上调用 Search 搜索叶子节点 如果 T 是叶子结点，并且T的MBR与 S 重叠。则 T 是合格记录。 Insertion描述：将新的条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E,设置N为根结点 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 SplitNode为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的MBR是否与搜索区域重叠，所以分割后的两个MBR的总面积应该最小。下图说明了这一点。 “坏分割”情况下MBR的面积比“好分割”情况下的大得多。 在进行节点分裂之前先了解一些变量 $S_{Extend}$：$S_{覆盖条目后的MBR} - S_{覆盖条目前的MBR}$，例如下图，假设叶子节点有一个条目A,现在加入条目B后的扩张面积为下图的绿色部分 $S_{ExtendDiff}$：$|A_{S_{Extend}} - B_{S_{Extend}}|$, 假设有两个叶子节点A、B分别包含一个条目，现在分别计算加入条目c的扩张面积$A_{S_{Extend}}$和$B_{S_{Extend}}$,然后便计算可得 下列是将 M+1 个条目的集合分成两组的算法：以下图为例：红色矩形是一个叶子节点，红色小正方形是叶子节点内的9个条目，目前叶子节点的条目数量已经满了，现在要插入这个绿色的条目到这个叶子节点中 穷举算法 把所有的分裂的可能都尝试一遍，复杂度太高就不介绍了 二次分裂 A Quadratic-Cost Algorithm 该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。这个分裂方式会造成很多重叠区域，以下是计算步骤 PickSeeds 先选择两个节点到分裂后的节点中去，计算每两个条目合并后的扩张面积，找到扩张面积最大的两个条目 图一中每个线段代表着两两配对计算一次扩张面积 图二的绿色部分为计算后，最大的扩张面积的两个条目 1. **ChoosePartition** 根据所得到的两个条目，新建两个叶子节点，然后开始分割，对剩余的每个条目计算AB两个节点的$S_{ExtendDiff}$，选择$S_{ExtendDiff}$最大的条目，加入到对应的节点中，然后重复上述过程，在下图的最后一步中，为保证分裂后的子节点数量合法，所以会把剩余的节点全给另一个\r线性分裂 A Linear-Cost Algorithm 与 Quadratic Split 仅区别在不同版本的PickSeeds。并且会造成更多的重叠区域，但是构建速度快一点 沿所有维度查找极端矩形 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。 调整矩形簇的形状 通过沿相应维度除以整个集合的宽度来标准化分离。 选择最极端的对 选择沿任何维度具有最大归一化分离的对。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:4","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#chooseleaf"},{"categories":null,"content":"\r算法介绍\rSearch给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个子节点的MBR 是否与 S 重叠。对于所有重叠的节点，在该节点上调用 Search 搜索叶子节点 如果 T 是叶子结点，并且T的MBR与 S 重叠。则 T 是合格记录。 Insertion描述：将新的条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E,设置N为根结点 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 SplitNode为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的MBR是否与搜索区域重叠，所以分割后的两个MBR的总面积应该最小。下图说明了这一点。 “坏分割”情况下MBR的面积比“好分割”情况下的大得多。 在进行节点分裂之前先了解一些变量 $S_{Extend}$：$S_{覆盖条目后的MBR} - S_{覆盖条目前的MBR}$，例如下图，假设叶子节点有一个条目A,现在加入条目B后的扩张面积为下图的绿色部分 $S_{ExtendDiff}$：$|A_{S_{Extend}} - B_{S_{Extend}}|$, 假设有两个叶子节点A、B分别包含一个条目，现在分别计算加入条目c的扩张面积$A_{S_{Extend}}$和$B_{S_{Extend}}$,然后便计算可得 下列是将 M+1 个条目的集合分成两组的算法：以下图为例：红色矩形是一个叶子节点，红色小正方形是叶子节点内的9个条目，目前叶子节点的条目数量已经满了，现在要插入这个绿色的条目到这个叶子节点中 穷举算法 把所有的分裂的可能都尝试一遍，复杂度太高就不介绍了 二次分裂 A Quadratic-Cost Algorithm 该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。这个分裂方式会造成很多重叠区域，以下是计算步骤 PickSeeds 先选择两个节点到分裂后的节点中去，计算每两个条目合并后的扩张面积，找到扩张面积最大的两个条目 图一中每个线段代表着两两配对计算一次扩张面积 图二的绿色部分为计算后，最大的扩张面积的两个条目 1. **ChoosePartition** 根据所得到的两个条目，新建两个叶子节点，然后开始分割，对剩余的每个条目计算AB两个节点的$S_{ExtendDiff}$，选择$S_{ExtendDiff}$最大的条目，加入到对应的节点中，然后重复上述过程，在下图的最后一步中，为保证分裂后的子节点数量合法，所以会把剩余的节点全给另一个\r线性分裂 A Linear-Cost Algorithm 与 Quadratic Split 仅区别在不同版本的PickSeeds。并且会造成更多的重叠区域，但是构建速度快一点 沿所有维度查找极端矩形 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。 调整矩形簇的形状 通过沿相应维度除以整个集合的宽度来标准化分离。 选择最极端的对 选择沿任何维度具有最大归一化分离的对。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:4","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#adjusttree"},{"categories":null,"content":"\r算法介绍\rSearch给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个子节点的MBR 是否与 S 重叠。对于所有重叠的节点，在该节点上调用 Search 搜索叶子节点 如果 T 是叶子结点，并且T的MBR与 S 重叠。则 T 是合格记录。 Insertion描述：将新的条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E,设置N为根结点 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 SplitNode为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的MBR是否与搜索区域重叠，所以分割后的两个MBR的总面积应该最小。下图说明了这一点。 “坏分割”情况下MBR的面积比“好分割”情况下的大得多。 在进行节点分裂之前先了解一些变量 $S_{Extend}$：$S_{覆盖条目后的MBR} - S_{覆盖条目前的MBR}$，例如下图，假设叶子节点有一个条目A,现在加入条目B后的扩张面积为下图的绿色部分 $S_{ExtendDiff}$：$|A_{S_{Extend}} - B_{S_{Extend}}|$, 假设有两个叶子节点A、B分别包含一个条目，现在分别计算加入条目c的扩张面积$A_{S_{Extend}}$和$B_{S_{Extend}}$,然后便计算可得 下列是将 M+1 个条目的集合分成两组的算法：以下图为例：红色矩形是一个叶子节点，红色小正方形是叶子节点内的9个条目，目前叶子节点的条目数量已经满了，现在要插入这个绿色的条目到这个叶子节点中 穷举算法 把所有的分裂的可能都尝试一遍，复杂度太高就不介绍了 二次分裂 A Quadratic-Cost Algorithm 该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。这个分裂方式会造成很多重叠区域，以下是计算步骤 PickSeeds 先选择两个节点到分裂后的节点中去，计算每两个条目合并后的扩张面积，找到扩张面积最大的两个条目 图一中每个线段代表着两两配对计算一次扩张面积 图二的绿色部分为计算后，最大的扩张面积的两个条目 1. **ChoosePartition** 根据所得到的两个条目，新建两个叶子节点，然后开始分割，对剩余的每个条目计算AB两个节点的$S_{ExtendDiff}$，选择$S_{ExtendDiff}$最大的条目，加入到对应的节点中，然后重复上述过程，在下图的最后一步中，为保证分裂后的子节点数量合法，所以会把剩余的节点全给另一个\r线性分裂 A Linear-Cost Algorithm 与 Quadratic Split 仅区别在不同版本的PickSeeds。并且会造成更多的重叠区域，但是构建速度快一点 沿所有维度查找极端矩形 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。 调整矩形簇的形状 通过沿相应维度除以整个集合的宽度来标准化分离。 选择最极端的对 选择沿任何维度具有最大归一化分离的对。 ","date":"2023-11-16","objectID":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/:1:4","series":["数据结构"],"tags":null,"title":"RTree","uri":"/posts/datastructure/%E4%BB%8Ertree%E5%88%B0rtree/#splitnode"},{"categories":null,"content":"\r隐式方程隐式表示是指用一个方程来表示曲线或曲面。例如，二维平面上的圆可以表示为： $$f(x,y) = x^2+y^2-1 = 0$$ 优点 容易表示无界的曲线曲面，如$f(x,y)=ax+by+c=0$所定义的直线。 容易判断点是否在曲线或者曲面上。 参数方程参数表示是指曲线上点的每个坐标分量均被表示为一个独立参数的显函数。例如，二维平面上的圆可以表示为： $$ \\begin{cases} x(u) = cos(u) \\ y(u) = sin(u) \\end{cases} 0\\leq u \\leq \\frac{\\pi}{2} $$ 优点 通过增加一个z坐标，很容易将参数方法推广到三位空间中任意曲线的表示，即：$C(u)=(x(u),y(u),z(u))$。 容易表示有界的曲线曲面，通过添加参数区间实现。 可以表示方向性，如设$a\\leq u \\leq b$，方向为从$C(a)$到$C(b)$。 更加直观自然，如Bezier和B样条中,系数具有重要的几何意义。 容易计算曲线或曲面上的点。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.1隐式和参数表示","uri":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/#"},{"categories":null,"content":"\r隐式方程隐式表示是指用一个方程来表示曲线或曲面。例如，二维平面上的圆可以表示为： $$f(x,y) = x^2+y^2-1 = 0$$ 优点 容易表示无界的曲线曲面，如$f(x,y)=ax+by+c=0$所定义的直线。 容易判断点是否在曲线或者曲面上。 参数方程参数表示是指曲线上点的每个坐标分量均被表示为一个独立参数的显函数。例如，二维平面上的圆可以表示为： $$ \\begin{cases} x(u) = cos(u) \\ y(u) = sin(u) \\end{cases} 0\\leq u \\leq \\frac{\\pi}{2} $$ 优点 通过增加一个z坐标，很容易将参数方法推广到三位空间中任意曲线的表示，即：$C(u)=(x(u),y(u),z(u))$。 容易表示有界的曲线曲面，通过添加参数区间实现。 可以表示方向性，如设$a\\leq u \\leq b$，方向为从$C(a)$到$C(b)$。 更加直观自然，如Bezier和B样条中,系数具有重要的几何意义。 容易计算曲线或曲面上的点。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.1隐式和参数表示","uri":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/#隐式方程"},{"categories":null,"content":"\r隐式方程隐式表示是指用一个方程来表示曲线或曲面。例如，二维平面上的圆可以表示为： $$f(x,y) = x^2+y^2-1 = 0$$ 优点 容易表示无界的曲线曲面，如$f(x,y)=ax+by+c=0$所定义的直线。 容易判断点是否在曲线或者曲面上。 参数方程参数表示是指曲线上点的每个坐标分量均被表示为一个独立参数的显函数。例如，二维平面上的圆可以表示为： $$ \\begin{cases} x(u) = cos(u) \\ y(u) = sin(u) \\end{cases} 0\\leq u \\leq \\frac{\\pi}{2} $$ 优点 通过增加一个z坐标，很容易将参数方法推广到三位空间中任意曲线的表示，即：$C(u)=(x(u),y(u),z(u))$。 容易表示有界的曲线曲面，通过添加参数区间实现。 可以表示方向性，如设$a\\leq u \\leq b$，方向为从$C(a)$到$C(b)$。 更加直观自然，如Bezier和B样条中,系数具有重要的几何意义。 容易计算曲线或曲面上的点。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.1隐式和参数表示","uri":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/#优点"},{"categories":null,"content":"\r隐式方程隐式表示是指用一个方程来表示曲线或曲面。例如，二维平面上的圆可以表示为： $$f(x,y) = x^2+y^2-1 = 0$$ 优点 容易表示无界的曲线曲面，如$f(x,y)=ax+by+c=0$所定义的直线。 容易判断点是否在曲线或者曲面上。 参数方程参数表示是指曲线上点的每个坐标分量均被表示为一个独立参数的显函数。例如，二维平面上的圆可以表示为： $$ \\begin{cases} x(u) = cos(u) \\ y(u) = sin(u) \\end{cases} 0\\leq u \\leq \\frac{\\pi}{2} $$ 优点 通过增加一个z坐标，很容易将参数方法推广到三位空间中任意曲线的表示，即：$C(u)=(x(u),y(u),z(u))$。 容易表示有界的曲线曲面，通过添加参数区间实现。 可以表示方向性，如设$a\\leq u \\leq b$，方向为从$C(a)$到$C(b)$。 更加直观自然，如Bezier和B样条中,系数具有重要的几何意义。 容易计算曲线或曲面上的点。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.1隐式和参数表示","uri":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/#参数方程"},{"categories":null,"content":"\r隐式方程隐式表示是指用一个方程来表示曲线或曲面。例如，二维平面上的圆可以表示为： $$f(x,y) = x^2+y^2-1 = 0$$ 优点 容易表示无界的曲线曲面，如$f(x,y)=ax+by+c=0$所定义的直线。 容易判断点是否在曲线或者曲面上。 参数方程参数表示是指曲线上点的每个坐标分量均被表示为一个独立参数的显函数。例如，二维平面上的圆可以表示为： $$ \\begin{cases} x(u) = cos(u) \\ y(u) = sin(u) \\end{cases} 0\\leq u \\leq \\frac{\\pi}{2} $$ 优点 通过增加一个z坐标，很容易将参数方法推广到三位空间中任意曲线的表示，即：$C(u)=(x(u),y(u),z(u))$。 容易表示有界的曲线曲面，通过添加参数区间实现。 可以表示方向性，如设$a\\leq u \\leq b$，方向为从$C(a)$到$C(b)$。 更加直观自然，如Bezier和B样条中,系数具有重要的几何意义。 容易计算曲线或曲面上的点。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.1隐式和参数表示","uri":"/posts/nurbs/1.1%E9%9A%90%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/#优点-1"},{"categories":null,"content":"幂基曲线（Power Basis Curve）是一种使用幂基函数（Power Basis Function）来表示的参数曲线。幂基曲线可以表示为一个多项式，这个多项式的基函数是一组幂函数。 一条$n$次曲线的幂基表示为 $$ C(u) = (x(u),y(u),z(u))=\\sum_{i=0}^{n}a_iu^i,0\\leq u \\leq 1 $$ 其中,$a_i=(x_i,y_i,z_i)$是矢量，因而 $$ \\begin{cases} x(u)=\\sum_{i=0}^{n}x_iu^i \\ y(u)=\\sum_{i=0}^{n}y_iu^i \\ z(u)=\\sum_{i=0}^{n}z_iu^i \\end{cases} $$ 当给定$u_0$，计算幂基曲线上的点$C(u_0)$的最有效算法是Horner1方法 次数=1时：$C(u_0) = a_1u_0+a_0$ 次数=2时：$C(u_0) = (a_2u_0+a_1)u_0+a_0$ 次数=n时：$C(u_0) = (…((a_nu_0+a_{n-1})+a_{n-2})u_0+…+a_1)u_0+a_0$ 具体算法如下： Horner(a,n,u0,C){ C=a[n] for(i=n-1;i\u003e=0;i--) C=C*u0+a[i] } 缺点 用于形状设计不够自然，系数$a_i$z只能传递很少的关于曲线形状的直观的几何印象，而且设计者通常需要指定曲线两端的顶点条件，不仅仅是起点处的条件 处理幂基多项式的算法更多地具有代数风格而非几何的风格 在数值计算上，当系数的数量级变化比较大时，Horner算发易于受舍入误差的影响 ","date":"2023-11-12","objectID":"/posts/nurbs/1.2%E5%B9%82%E5%9F%BA%E6%9B%B2%E7%BA%BF/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.2幂基曲线","uri":"/posts/nurbs/1.2%E5%B9%82%E5%9F%BA%E6%9B%B2%E7%BA%BF/#"},{"categories":null,"content":"幂基曲线（Power Basis Curve）是一种使用幂基函数（Power Basis Function）来表示的参数曲线。幂基曲线可以表示为一个多项式，这个多项式的基函数是一组幂函数。 一条$n$次曲线的幂基表示为 $$ C(u) = (x(u),y(u),z(u))=\\sum_{i=0}^{n}a_iu^i,0\\leq u \\leq 1 $$ 其中,$a_i=(x_i,y_i,z_i)$是矢量，因而 $$ \\begin{cases} x(u)=\\sum_{i=0}^{n}x_iu^i \\ y(u)=\\sum_{i=0}^{n}y_iu^i \\ z(u)=\\sum_{i=0}^{n}z_iu^i \\end{cases} $$ 当给定$u_0$，计算幂基曲线上的点$C(u_0)$的最有效算法是Horner1方法 次数=1时：$C(u_0) = a_1u_0+a_0$ 次数=2时：$C(u_0) = (a_2u_0+a_1)u_0+a_0$ 次数=n时：$C(u_0) = (…((a_nu_0+a_{n-1})+a_{n-2})u_0+…+a_1)u_0+a_0$ 具体算法如下： Horner(a,n,u0,C){ C=a[n] for(i=n-1;i\u003e=0;i--) C=C*u0+a[i] } 缺点 用于形状设计不够自然，系数$a_i$z只能传递很少的关于曲线形状的直观的几何印象，而且设计者通常需要指定曲线两端的顶点条件，不仅仅是起点处的条件 处理幂基多项式的算法更多地具有代数风格而非几何的风格 在数值计算上，当系数的数量级变化比较大时，Horner算发易于受舍入误差的影响 ","date":"2023-11-12","objectID":"/posts/nurbs/1.2%E5%B9%82%E5%9F%BA%E6%9B%B2%E7%BA%BF/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.2幂基曲线","uri":"/posts/nurbs/1.2%E5%B9%82%E5%9F%BA%E6%9B%B2%E7%BA%BF/#缺点"},{"categories":null,"content":"\r注解 Horner算法（Horner’s Method）又称霍纳法则，是一种高效地计算多项式值的算法。它通过减少乘法和加法的次数来提高计算效率。Horner算法在计算机科学和数值分析等领域有广泛应用。 假设我们有一个多项式 $P(x)$，表示为： $$ P(x) = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0 $$ 我们需要计算 $P(x)$ 在某个给定值 $x_0$ 处的函数值。使用Horner算法，我们可以将多项式重新表示为： $$ P(x) = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0 = ((\\dots ((a_n x + a_{n-1}) x + a_{n-2}) \\dots ) x + a_1) x + a_0 $$ 然后按照这个嵌套的形式计算多项式的值。这样做的优点是减少了乘法和加法的次数，从而提高了计算效率。 Horner算法的时间复杂度为 $O(n)$，其中 $n$ 是多项式的阶数。 ↩︎ ","date":"2023-11-12","objectID":"/posts/nurbs/1.2%E5%B9%82%E5%9F%BA%E6%9B%B2%E7%BA%BF/:0:1","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.2幂基曲线","uri":"/posts/nurbs/1.2%E5%B9%82%E5%9F%BA%E6%9B%B2%E7%BA%BF/#注解"},{"categories":null,"content":"贝塞尔曲线是一种幂基曲线。一条n次Bezier曲线可以表示为 $$ C(u)=\\sum_{i=0}^nB_{i,n}(u)P_i,0\\leq u \\leq 1 $$ 其中，基函数（也称为混合函数）$B_{i,n}(u)$是著名的n次Bernstein（伯恩斯坦多项式），其定义为 $$ B_{i,n}(u)=\\frac{n!}{i!(n-i)!}u^i(1-u)^{n-i} $$ Bernstein多项式性质 非负性：对所有的$i,n$和$0 \\leq u \\leq 1$ ,$B_{i,n}(u) \\geq 0$ 规范性：$\\sum_{i=0}^nB_{i,n}(u) = 1$,对所有的$0 \\leq u \\leq 1$ 端点性质：$B_{0,n}(u)=B_{n,n}(u)=1$ 最大值$B_{i,n}(u)$在区间$[1,0]$内只达到一次，既仅当$u=\\frac{ i}{n}$时，$B_{i,n}(u)$取得最大值 对称性：对于任意$n \\gt 0$,多项式$B_{i,n}(u)$是关于$u=\\frac{1}{2}$对称的 递推性质：$B_{i,n}(u)=(1-u)B_{i,n-1}(u) +uB_{i-1,n-1}(u)$,这里规定当$i \\lt 0$或$i \\gt n$时，$B_{i,n}(u) = 0$ 求导公式：$\\dot{{B}}{i,n}(u)= \\frac{dB{i,n}(u)}{du} = n(B_{i-1,n-1}(u)-B_{i,n-1}(u))$ De Casteljau’s algorithm德卡斯特里奥算法是计算伯恩斯坦形式的多项式或贝塞尔曲线的递归方法。 $$P_{k,i}(u_o)=(1-u_0)P_{k-1,i}(u_o)+u_0P_{k-1,i+1}(u_o)$$\r![Bézier_2_big]()![Bézier_3_big]()![Bézier_4_big]()\r利用DeCasteljau算法计算Bezier曲线上的一个点 DeCasteljau(P,n,u){ for (i=0;i\u003c=n;i++) Q[i]=P[i]; for (k=1;k\u003c=n;k++) for(i=0;i\u003c=n;i++) Q[i]=(1.0-u)*Q[i]+u*Q[i+1]; c=Q[0]; } //先求出P0 P1 ....Pn //在求出P1,0 P1,1 P1,2 ....P1,n-1 //在求出P2,0 P2,1 P2,2 ....P2,n-2 //... //在求出Pn-1,0 Pn-1,1 //Pn,0 便是曲线在u时的点 ","date":"2023-11-12","objectID":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.3Bezier曲线","uri":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/#"},{"categories":null,"content":"贝塞尔曲线是一种幂基曲线。一条n次Bezier曲线可以表示为 $$ C(u)=\\sum_{i=0}^nB_{i,n}(u)P_i,0\\leq u \\leq 1 $$ 其中，基函数（也称为混合函数）$B_{i,n}(u)$是著名的n次Bernstein（伯恩斯坦多项式），其定义为 $$ B_{i,n}(u)=\\frac{n!}{i!(n-i)!}u^i(1-u)^{n-i} $$ Bernstein多项式性质 非负性：对所有的$i,n$和$0 \\leq u \\leq 1$ ,$B_{i,n}(u) \\geq 0$ 规范性：$\\sum_{i=0}^nB_{i,n}(u) = 1$,对所有的$0 \\leq u \\leq 1$ 端点性质：$B_{0,n}(u)=B_{n,n}(u)=1$ 最大值$B_{i,n}(u)$在区间$[1,0]$内只达到一次，既仅当$u=\\frac{ i}{n}$时，$B_{i,n}(u)$取得最大值 对称性：对于任意$n \\gt 0$,多项式$B_{i,n}(u)$是关于$u=\\frac{1}{2}$对称的 递推性质：$B_{i,n}(u)=(1-u)B_{i,n-1}(u) +uB_{i-1,n-1}(u)$,这里规定当$i \\lt 0$或$i \\gt n$时，$B_{i,n}(u) = 0$ 求导公式：$\\dot{{B}}{i,n}(u)= \\frac{dB{i,n}(u)}{du} = n(B_{i-1,n-1}(u)-B_{i,n-1}(u))$ De Casteljau’s algorithm德卡斯特里奥算法是计算伯恩斯坦形式的多项式或贝塞尔曲线的递归方法。 $$P_{k,i}(u_o)=(1-u_0)P_{k-1,i}(u_o)+u_0P_{k-1,i+1}(u_o)$$\r![Bézier_2_big]()![Bézier_3_big]()![Bézier_4_big]()\r利用DeCasteljau算法计算Bezier曲线上的一个点 DeCasteljau(P,n,u){ for (i=0;i\u003c=n;i++) Q[i]=P[i]; for (k=1;k\u003c=n;k++) for(i=0;i\u003c=n;i++) Q[i]=(1.0-u)*Q[i]+u*Q[i+1]; c=Q[0]; } //先求出P0 P1 ....Pn //在求出P1,0 P1,1 P1,2 ....P1,n-1 //在求出P2,0 P2,1 P2,2 ....P2,n-2 //... //在求出Pn-1,0 Pn-1,1 //Pn,0 便是曲线在u时的点 ","date":"2023-11-12","objectID":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.3Bezier曲线","uri":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/#bernstein多项式性质"},{"categories":null,"content":"贝塞尔曲线是一种幂基曲线。一条n次Bezier曲线可以表示为 $$ C(u)=\\sum_{i=0}^nB_{i,n}(u)P_i,0\\leq u \\leq 1 $$ 其中，基函数（也称为混合函数）$B_{i,n}(u)$是著名的n次Bernstein（伯恩斯坦多项式），其定义为 $$ B_{i,n}(u)=\\frac{n!}{i!(n-i)!}u^i(1-u)^{n-i} $$ Bernstein多项式性质 非负性：对所有的$i,n$和$0 \\leq u \\leq 1$ ,$B_{i,n}(u) \\geq 0$ 规范性：$\\sum_{i=0}^nB_{i,n}(u) = 1$,对所有的$0 \\leq u \\leq 1$ 端点性质：$B_{0,n}(u)=B_{n,n}(u)=1$ 最大值$B_{i,n}(u)$在区间$[1,0]$内只达到一次，既仅当$u=\\frac{ i}{n}$时，$B_{i,n}(u)$取得最大值 对称性：对于任意$n \\gt 0$,多项式$B_{i,n}(u)$是关于$u=\\frac{1}{2}$对称的 递推性质：$B_{i,n}(u)=(1-u)B_{i,n-1}(u) +uB_{i-1,n-1}(u)$,这里规定当$i \\lt 0$或$i \\gt n$时，$B_{i,n}(u) = 0$ 求导公式：$\\dot{{B}}{i,n}(u)= \\frac{dB{i,n}(u)}{du} = n(B_{i-1,n-1}(u)-B_{i,n-1}(u))$ De Casteljau’s algorithm德卡斯特里奥算法是计算伯恩斯坦形式的多项式或贝塞尔曲线的递归方法。 $$P_{k,i}(u_o)=(1-u_0)P_{k-1,i}(u_o)+u_0P_{k-1,i+1}(u_o)$$\r![Bézier_2_big]()![Bézier_3_big]()![Bézier_4_big]()\r利用DeCasteljau算法计算Bezier曲线上的一个点 DeCasteljau(P,n,u){ for (i=0;i\u003c=n;i++) Q[i]=P[i]; for (k=1;k\u003c=n;k++) for(i=0;i\u003c=n;i++) Q[i]=(1.0-u)*Q[i]+u*Q[i+1]; c=Q[0]; } //先求出P0 P1 ....Pn //在求出P1,0 P1,1 P1,2 ....P1,n-1 //在求出P2,0 P2,1 P2,2 ....P2,n-2 //... //在求出Pn-1,0 Pn-1,1 //Pn,0 便是曲线在u时的点 ","date":"2023-11-12","objectID":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.3Bezier曲线","uri":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/#de-casteljaus-algorithm德卡斯特里奥算法"},{"categories":null,"content":"贝塞尔曲线是一种幂基曲线。一条n次Bezier曲线可以表示为 $$ C(u)=\\sum_{i=0}^nB_{i,n}(u)P_i,0\\leq u \\leq 1 $$ 其中，基函数（也称为混合函数）$B_{i,n}(u)$是著名的n次Bernstein（伯恩斯坦多项式），其定义为 $$ B_{i,n}(u)=\\frac{n!}{i!(n-i)!}u^i(1-u)^{n-i} $$ Bernstein多项式性质 非负性：对所有的$i,n$和$0 \\leq u \\leq 1$ ,$B_{i,n}(u) \\geq 0$ 规范性：$\\sum_{i=0}^nB_{i,n}(u) = 1$,对所有的$0 \\leq u \\leq 1$ 端点性质：$B_{0,n}(u)=B_{n,n}(u)=1$ 最大值$B_{i,n}(u)$在区间$[1,0]$内只达到一次，既仅当$u=\\frac{ i}{n}$时，$B_{i,n}(u)$取得最大值 对称性：对于任意$n \\gt 0$,多项式$B_{i,n}(u)$是关于$u=\\frac{1}{2}$对称的 递推性质：$B_{i,n}(u)=(1-u)B_{i,n-1}(u) +uB_{i-1,n-1}(u)$,这里规定当$i \\lt 0$或$i \\gt n$时，$B_{i,n}(u) = 0$ 求导公式：$\\dot{{B}}{i,n}(u)= \\frac{dB{i,n}(u)}{du} = n(B_{i-1,n-1}(u)-B_{i,n-1}(u))$ De Casteljau’s algorithm德卡斯特里奥算法是计算伯恩斯坦形式的多项式或贝塞尔曲线的递归方法。 $$P_{k,i}(u_o)=(1-u_0)P_{k-1,i}(u_o)+u_0P_{k-1,i+1}(u_o)$$\r![Bézier_2_big]()![Bézier_3_big]()![Bézier_4_big]()\r利用DeCasteljau算法计算Bezier曲线上的一个点 DeCasteljau(P,n,u){ for (i=0;i\u003c=n;i++) Q[i]=P[i]; for (k=1;k\u003c=n;k++) for(i=0;i\u003c=n;i++) Q[i]=(1.0-u)*Q[i]+u*Q[i+1]; c=Q[0]; } //先求出P0 P1 ....Pn //在求出P1,0 P1,1 P1,2 ....P1,n-1 //在求出P2,0 P2,1 P2,2 ....P2,n-2 //... //在求出Pn-1,0 Pn-1,1 //Pn,0 便是曲线在u时的点 ","date":"2023-11-12","objectID":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.3Bezier曲线","uri":"/posts/nurbs/1.3bezier%E6%9B%B2%E7%BA%BF/#p_kiu_o1-u_0p_k-1iu_ou_0p_k-1i1u_o"},{"categories":null,"content":"用有理函数1表示Bezier曲线，有理Bezier曲线用有理函数表示的目的就是为了引入权重因子。权重因子使得有理Bezier曲线相较于Bezier曲线具有更强的表示能力和逼近能力。 $$ x(u)=\\frac{X(u)}{W(u)},;;y(u)=\\frac{Y(u)}{W(u)} $$ n次有理Bezier曲线的定义为 $$ C(u)=\\frac{\\sum_{i=0}^nB_{i,n}(u)w_iP_i}{\\sum_{i=0}^nB_{i,n}(u)w_i}, ;;0 \\leq u \\leq1 $$ 可以理解为将原本的$P=(x,y,z)$用齐次坐标表示为$P^w=(wx,wy,wz,w)$，$w$便是权重因子，用$P^w$构造四维空间中的非有理Bezier曲线。在映射到三维空间中,以二维空间的有理Bezier曲线为例，构造三维的Bezier曲线。如下图：$P_0=(1，0)，P_1=(1,1),P_2=(0,1),w_0=1,w_1=1,w_2=2,$因此三维控制点是$P_0^w=(1,0,1),P_1^w= (1,1,1),P_2^w=(0,2,2)$,将$C^w(u)$投影到平面$W=1$上，便是二维的圆弧。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.4%E6%9C%89%E7%90%86bezier%E6%9B%B2%E7%BA%BF/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.4有理Bezier曲线","uri":"/posts/nurbs/1.4%E6%9C%89%E7%90%86bezier%E6%9B%B2%E7%BA%BF/#"},{"categories":null,"content":"\r注解 有理函数是一个由两个多项式相除组成的函数，可以表示为： $$ R(x)=\\frac{P(x)}{Q(x)} $$ 其中 $P(x)$ 和 $Q(x)$ 分别是分子和分母多项式，$Q(x)$ 不恒等于零。 ↩︎ ","date":"2023-11-12","objectID":"/posts/nurbs/1.4%E6%9C%89%E7%90%86bezier%E6%9B%B2%E7%BA%BF/:0:1","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.4有理Bezier曲线","uri":"/posts/nurbs/1.4%E6%9C%89%E7%90%86bezier%E6%9B%B2%E7%BA%BF/#注解"},{"categories":null,"content":"张量积方法是在两个方向上均采用曲线的处理方式，也采用基函数和对应的几何系数的乘积之和的形式表示曲面，基函数是$u$和$v$的二元函数，它由关于$u$的一元基函数和关于$v$的一元基函数的乘积来构造[^1]，。张量积曲面具有以下形式： $$ S(u,v)=(x(u,v),y(u,v),z(u,v))=\\sum_{i=0}^n\\sum_{j=0}^mf_i(u)g_i(v)b_{i,j} $$ 其中 $$ \\begin{cases} b_{i,j}=(x_{i,j},y_{i,j},z_{i,j}) \\ 0 \\leq u, v \\leq 1 \\end{cases} $$ 如果固定$u=u_0$，那么 $$ C_{u_0}(v)=S(U=0,v)=\\sum_{j=0}^m(\\sum_{i=0}^na_{i,j}u_0)v^j=\\sum_{j=0}^mb_j(u_0)v^j $$ 是位于曲面$S(u,v)$上的幂基曲线，其中$b_j(u_0)=\\sum_{i=0}^na_{i,j}u_0$,即$u_0$时$u$方向曲线的Bernstein多项式。这称为等参数曲线（isoparametric curve）或（isocurve）。 计算幂基曲面上的也可以运用Horner算法，其一般过程是，先沿着一个方向运用曲线的算法对张量积曲面系数的每一行处理，再沿着另一个方向对所得结果的每一列进行处理。 Bezier曲面 Bezier曲面是张量积曲面或幂基曲面，对于Bezier曲面上求点，依旧可以运用DeCasteljau算法，其过程也是先沿着一个方向运用DeCasteljau算法求得等参曲线，然后在等参曲线上在运用DeCasteljau算法求得$uv$点 有理Bezier曲面不是张量积曲面，因为权重因子的引入，有理Bezier曲面的计算过程变为非线性。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.5%E5%BC%A0%E9%87%8F%E7%A7%AF%E6%9B%B2%E9%9D%A2/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.5张量积曲面","uri":"/posts/nurbs/1.5%E5%BC%A0%E9%87%8F%E7%A7%AF%E6%9B%B2%E9%9D%A2/#"},{"categories":null,"content":"张量积方法是在两个方向上均采用曲线的处理方式，也采用基函数和对应的几何系数的乘积之和的形式表示曲面，基函数是$u$和$v$的二元函数，它由关于$u$的一元基函数和关于$v$的一元基函数的乘积来构造[^1]，。张量积曲面具有以下形式： $$ S(u,v)=(x(u,v),y(u,v),z(u,v))=\\sum_{i=0}^n\\sum_{j=0}^mf_i(u)g_i(v)b_{i,j} $$ 其中 $$ \\begin{cases} b_{i,j}=(x_{i,j},y_{i,j},z_{i,j}) \\ 0 \\leq u, v \\leq 1 \\end{cases} $$ 如果固定$u=u_0$，那么 $$ C_{u_0}(v)=S(U=0,v)=\\sum_{j=0}^m(\\sum_{i=0}^na_{i,j}u_0)v^j=\\sum_{j=0}^mb_j(u_0)v^j $$ 是位于曲面$S(u,v)$上的幂基曲线，其中$b_j(u_0)=\\sum_{i=0}^na_{i,j}u_0$,即$u_0$时$u$方向曲线的Bernstein多项式。这称为等参数曲线（isoparametric curve）或（isocurve）。 计算幂基曲面上的也可以运用Horner算法，其一般过程是，先沿着一个方向运用曲线的算法对张量积曲面系数的每一行处理，再沿着另一个方向对所得结果的每一列进行处理。 Bezier曲面 Bezier曲面是张量积曲面或幂基曲面，对于Bezier曲面上求点，依旧可以运用DeCasteljau算法，其过程也是先沿着一个方向运用DeCasteljau算法求得等参曲线，然后在等参曲线上在运用DeCasteljau算法求得$uv$点 有理Bezier曲面不是张量积曲面，因为权重因子的引入，有理Bezier曲面的计算过程变为非线性。 ","date":"2023-11-12","objectID":"/posts/nurbs/1.5%E5%BC%A0%E9%87%8F%E7%A7%AF%E6%9B%B2%E9%9D%A2/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"1.5张量积曲面","uri":"/posts/nurbs/1.5%E5%BC%A0%E9%87%8F%E7%A7%AF%E6%9B%B2%E9%9D%A2/#bezier曲面"},{"categories":null,"content":"\rBezier曲线的缺点 表示能力有限：Bezier曲线无法直接表示某些常见的几何形状，例如圆和椭圆。为了表示这些形状，可能需要将多个Bezier曲线拼接起来，这会增加计算复杂度和实现难度。 全局控制性差：当调整Bezier曲线上的一个控制点时，整条曲线都会受到影响。这意味着，如果想要局部调整曲线形状，可能会影响到其他部分。 阶数敏感：随着曲线阶数的增加，Bezier曲线的计算复杂度会显著增加。高阶曲线可能导致计算效率低下，并且在某些情况下可能出现数值不稳定性。 参数分布不均匀：Bezier曲线的参数分布可能不均匀，导致某些部分的曲线细节难以捕捉。这可能需要增加曲线的阶数，但这又会导致计算复杂度增加。 缺乏局部修改能力：对于高阶Bezier曲线，如果想要对曲线的一部分进行修改，可能需要对所有控制点进行调整。这在计算机辅助设计和建模过程中可能造成困扰。 分段多项式曲线分段多项式曲线的基本思想是将参数域分为多个子区间，每个子区间上分别定义一个多项式曲线。分段多项式曲线的关键在于确保各个子区间之间的曲线拼接得当，以保证良好的几何连续性。将多个Bezier曲线连接在一起，使得在连接处保持一定的几何连续性。 分段Bezier曲线曲线将多个贝塞尔曲线连接在一起，使得在连接处保持一定的几何连续性。分段贝塞尔曲线的局部控制特性较好，但为了保持每段之间的连续性，如C1连续，调整控制点的灵活性便会降低。 ","date":"2023-11-12","objectID":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.1前言","uri":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/#"},{"categories":null,"content":"\rBezier曲线的缺点 表示能力有限：Bezier曲线无法直接表示某些常见的几何形状，例如圆和椭圆。为了表示这些形状，可能需要将多个Bezier曲线拼接起来，这会增加计算复杂度和实现难度。 全局控制性差：当调整Bezier曲线上的一个控制点时，整条曲线都会受到影响。这意味着，如果想要局部调整曲线形状，可能会影响到其他部分。 阶数敏感：随着曲线阶数的增加，Bezier曲线的计算复杂度会显著增加。高阶曲线可能导致计算效率低下，并且在某些情况下可能出现数值不稳定性。 参数分布不均匀：Bezier曲线的参数分布可能不均匀，导致某些部分的曲线细节难以捕捉。这可能需要增加曲线的阶数，但这又会导致计算复杂度增加。 缺乏局部修改能力：对于高阶Bezier曲线，如果想要对曲线的一部分进行修改，可能需要对所有控制点进行调整。这在计算机辅助设计和建模过程中可能造成困扰。 分段多项式曲线分段多项式曲线的基本思想是将参数域分为多个子区间，每个子区间上分别定义一个多项式曲线。分段多项式曲线的关键在于确保各个子区间之间的曲线拼接得当，以保证良好的几何连续性。将多个Bezier曲线连接在一起，使得在连接处保持一定的几何连续性。 分段Bezier曲线曲线将多个贝塞尔曲线连接在一起，使得在连接处保持一定的几何连续性。分段贝塞尔曲线的局部控制特性较好，但为了保持每段之间的连续性，如C1连续，调整控制点的灵活性便会降低。 ","date":"2023-11-12","objectID":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.1前言","uri":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/#bezier曲线的缺点"},{"categories":null,"content":"\rBezier曲线的缺点 表示能力有限：Bezier曲线无法直接表示某些常见的几何形状，例如圆和椭圆。为了表示这些形状，可能需要将多个Bezier曲线拼接起来，这会增加计算复杂度和实现难度。 全局控制性差：当调整Bezier曲线上的一个控制点时，整条曲线都会受到影响。这意味着，如果想要局部调整曲线形状，可能会影响到其他部分。 阶数敏感：随着曲线阶数的增加，Bezier曲线的计算复杂度会显著增加。高阶曲线可能导致计算效率低下，并且在某些情况下可能出现数值不稳定性。 参数分布不均匀：Bezier曲线的参数分布可能不均匀，导致某些部分的曲线细节难以捕捉。这可能需要增加曲线的阶数，但这又会导致计算复杂度增加。 缺乏局部修改能力：对于高阶Bezier曲线，如果想要对曲线的一部分进行修改，可能需要对所有控制点进行调整。这在计算机辅助设计和建模过程中可能造成困扰。 分段多项式曲线分段多项式曲线的基本思想是将参数域分为多个子区间，每个子区间上分别定义一个多项式曲线。分段多项式曲线的关键在于确保各个子区间之间的曲线拼接得当，以保证良好的几何连续性。将多个Bezier曲线连接在一起，使得在连接处保持一定的几何连续性。 分段Bezier曲线曲线将多个贝塞尔曲线连接在一起，使得在连接处保持一定的几何连续性。分段贝塞尔曲线的局部控制特性较好，但为了保持每段之间的连续性，如C1连续，调整控制点的灵活性便会降低。 ","date":"2023-11-12","objectID":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.1前言","uri":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/#分段多项式曲线"},{"categories":null,"content":"\rBezier曲线的缺点 表示能力有限：Bezier曲线无法直接表示某些常见的几何形状，例如圆和椭圆。为了表示这些形状，可能需要将多个Bezier曲线拼接起来，这会增加计算复杂度和实现难度。 全局控制性差：当调整Bezier曲线上的一个控制点时，整条曲线都会受到影响。这意味着，如果想要局部调整曲线形状，可能会影响到其他部分。 阶数敏感：随着曲线阶数的增加，Bezier曲线的计算复杂度会显著增加。高阶曲线可能导致计算效率低下，并且在某些情况下可能出现数值不稳定性。 参数分布不均匀：Bezier曲线的参数分布可能不均匀，导致某些部分的曲线细节难以捕捉。这可能需要增加曲线的阶数，但这又会导致计算复杂度增加。 缺乏局部修改能力：对于高阶Bezier曲线，如果想要对曲线的一部分进行修改，可能需要对所有控制点进行调整。这在计算机辅助设计和建模过程中可能造成困扰。 分段多项式曲线分段多项式曲线的基本思想是将参数域分为多个子区间，每个子区间上分别定义一个多项式曲线。分段多项式曲线的关键在于确保各个子区间之间的曲线拼接得当，以保证良好的几何连续性。将多个Bezier曲线连接在一起，使得在连接处保持一定的几何连续性。 分段Bezier曲线曲线将多个贝塞尔曲线连接在一起，使得在连接处保持一定的几何连续性。分段贝塞尔曲线的局部控制特性较好，但为了保持每段之间的连续性，如C1连续，调整控制点的灵活性便会降低。 ","date":"2023-11-12","objectID":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.1前言","uri":"/posts/nurbs/2.1%E5%89%8D%E8%A8%80/#分段bezier曲线曲线"},{"categories":null,"content":"\r定义$$ N_{i,0}(u)= \\begin{cases} 1 ;;若u_i \\leq u\u003cu_{i+1} \\ 0 ;;其他 \\end{cases} $$ $$ N_{i,p}(u)=\\frac{u-u_i}{u_{i+p}-u_i}N_{i,p-1}(u)+\\frac{u_{i+p+1}-u}{u_{i+p+1}-u_{i+1}}N_{i+1,p-1}(u)(u) $$ $N_{i,0}(u)$是阶梯函数，他在半开区间$u \\in [u_i,u_{i+1})$外都为零。 当$P\u003e0$时，$N_{i,p}(u)$是两个$p-1$次基函数的线性组合。 半开区间$[u_i,u_{i+1})$称为第$i$个节点区间(knot span)，相邻节点可以相同，所以长度可以为零。 性质\r局部支持性：如果$u \\notin [u_i,u_{i+p+1})$,则$N_{i,0}(u)=0$： 在节点区间$[u_i,u_{i+1})$中，最多$p+1$个$N_{i,p}$是非零的： 非负性：对所有的$i,p,u$，有$N_{i,0}(u) \\geq 0$ 规范性：对任意节点区间$[u_i,u_{i+1})$，但$u \\in [u_i,u_{i+1})$时，$\\sum_{i-p}^iN_{j,q}(u)=1$ 可微性：在节点区间内部，$N_{i,0}(u)$是无限次可微的，在节点处$N_{i,0}(u)$是$p-k$次连续可微的，其中$k$是节点的重复度（最低为1）。 除$p=0$的情况以外，$N_{i,p}(u)严格地达到最大值一次$。 ","date":"2023-11-12","objectID":"/posts/nurbs/2.2b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.2 B样条基函数的定义和性质","uri":"/posts/nurbs/2.2b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/#"},{"categories":null,"content":"\r定义$$ N_{i,0}(u)= \\begin{cases} 1 ;;若u_i \\leq u0$时，$N_{i,p}(u)$是两个$p-1$次基函数的线性组合。 半开区间$[u_i,u_{i+1})$称为第$i$个节点区间(knot span)，相邻节点可以相同，所以长度可以为零。 性质\r局部支持性：如果$u \\notin [u_i,u_{i+p+1})$,则$N_{i,0}(u)=0$： 在节点区间$[u_i,u_{i+1})$中，最多$p+1$个$N_{i,p}$是非零的： 非负性：对所有的$i,p,u$，有$N_{i,0}(u) \\geq 0$ 规范性：对任意节点区间$[u_i,u_{i+1})$，但$u \\in [u_i,u_{i+1})$时，$\\sum_{i-p}^iN_{j,q}(u)=1$ 可微性：在节点区间内部，$N_{i,0}(u)$是无限次可微的，在节点处$N_{i,0}(u)$是$p-k$次连续可微的，其中$k$是节点的重复度（最低为1）。 除$p=0$的情况以外，$N_{i,p}(u)严格地达到最大值一次$。 ","date":"2023-11-12","objectID":"/posts/nurbs/2.2b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.2 B样条基函数的定义和性质","uri":"/posts/nurbs/2.2b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/#定义"},{"categories":null,"content":"\r定义$$ N_{i,0}(u)= \\begin{cases} 1 ;;若u_i \\leq u0$时，$N_{i,p}(u)$是两个$p-1$次基函数的线性组合。 半开区间$[u_i,u_{i+1})$称为第$i$个节点区间(knot span)，相邻节点可以相同，所以长度可以为零。 性质\r局部支持性：如果$u \\notin [u_i,u_{i+p+1})$,则$N_{i,0}(u)=0$： 在节点区间$[u_i,u_{i+1})$中，最多$p+1$个$N_{i,p}$是非零的： 非负性：对所有的$i,p,u$，有$N_{i,0}(u) \\geq 0$ 规范性：对任意节点区间$[u_i,u_{i+1})$，但$u \\in [u_i,u_{i+1})$时，$\\sum_{i-p}^iN_{j,q}(u)=1$ 可微性：在节点区间内部，$N_{i,0}(u)$是无限次可微的，在节点处$N_{i,0}(u)$是$p-k$次连续可微的，其中$k$是节点的重复度（最低为1）。 除$p=0$的情况以外，$N_{i,p}(u)严格地达到最大值一次$。 ","date":"2023-11-12","objectID":"/posts/nurbs/2.2b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.2 B样条基函数的定义和性质","uri":"/posts/nurbs/2.2b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/#性质"},{"categories":null,"content":"\r略 ","date":"2023-11-12","objectID":"/posts/nurbs/2.3b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/:0:1","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.3 B样条基函数的导数","uri":"/posts/nurbs/2.3b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/#heading"},{"categories":null,"content":"\r基函数$N_{i,p}(u)$的节点矢量的第一个和最后一个系欸但那具有重复度$p+1$ 定义在节点矢量上的$p$次B样条基函数是$p$次$Bernstein$多项式 ","date":"2023-11-12","objectID":"/posts/nurbs/2.4b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E6%80%A7%E8%B4%A8/:0:1","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.4 B样条基函数进一步的性质","uri":"/posts/nurbs/2.4b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E6%80%A7%E8%B4%A8/#heading"},{"categories":null,"content":"令$U={u_0,u_1,u_2,…,u_m}$为节点矢量，假设我们感兴趣的是$p$次基函数，并假设$u$是固定的，$u \\in [u_i,u_{i+1}]$ 计算节点区间的下标通过二分法搜索 //n 控制点的数量减一 //p 曲线的次数 //u 要查找的参数值 //U 节点向量数组 int FindSpan(n,p,u,U){ if(u == U[n+1]) return n low = p; hight = n+1; mid = (low+hight)/2; while(u\u003cU[mid] || u\u003eU[mid+1]){ if(u\u003cU[mid]) hight = mid; else low = mid; } return (mid); } 计算$N_{i-p},…,N_{i,p}$假设$u$在第$i$个节点区间内，计算所有的非零B样条基函数的过程如下图的一个倒置三角形 然后令$left[j]=u-u_{i+1-j}, ;;;;;; left[j]=u_{i+j}-u$，如下图 BasisFuns(i,u,p,U,N){ N[0]=1.0 for(j=1;j\u003c=p;j++\u003e){ left[j]=u-U[i+1-j]; right[j]=U[i+j]-u; saved = 0.0; for(r=0;r\u003cj;r++){ temp=N[r]/(right[r+1]+left[j-r]); N[r]=saved+right[r+1]*temp; saved=left[j-r]*temp; } N[j]=saved; } } 计算导数\r略","date":"2023-11-12","objectID":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.5B样条基函数的计算","uri":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/#"},{"categories":null,"content":"令$U={u_0,u_1,u_2,…,u_m}$为节点矢量，假设我们感兴趣的是$p$次基函数，并假设$u$是固定的，$u \\in [u_i,u_{i+1}]$ 计算节点区间的下标通过二分法搜索 //n 控制点的数量减一 //p 曲线的次数 //u 要查找的参数值 //U 节点向量数组 int FindSpan(n,p,u,U){ if(u == U[n+1]) return n low = p; hight = n+1; mid = (low+hight)/2; while(uU[mid+1]){ if(u){ left[j]=u-U[i+1-j]; right[j]=U[i+j]-u; saved = 0.0; for(r=0;r","date":"2023-11-12","objectID":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.5B样条基函数的计算","uri":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/#计算节点区间的下标"},{"categories":null,"content":"令$U={u_0,u_1,u_2,…,u_m}$为节点矢量，假设我们感兴趣的是$p$次基函数，并假设$u$是固定的，$u \\in [u_i,u_{i+1}]$ 计算节点区间的下标通过二分法搜索 //n 控制点的数量减一 //p 曲线的次数 //u 要查找的参数值 //U 节点向量数组 int FindSpan(n,p,u,U){ if(u == U[n+1]) return n low = p; hight = n+1; mid = (low+hight)/2; while(uU[mid+1]){ if(u){ left[j]=u-U[i+1-j]; right[j]=U[i+j]-u; saved = 0.0; for(r=0;r","date":"2023-11-12","objectID":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.5B样条基函数的计算","uri":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/#计算n_i-pn_ip"},{"categories":null,"content":"令$U={u_0,u_1,u_2,…,u_m}$为节点矢量，假设我们感兴趣的是$p$次基函数，并假设$u$是固定的，$u \\in [u_i,u_{i+1}]$ 计算节点区间的下标通过二分法搜索 //n 控制点的数量减一 //p 曲线的次数 //u 要查找的参数值 //U 节点向量数组 int FindSpan(n,p,u,U){ if(u == U[n+1]) return n low = p; hight = n+1; mid = (low+hight)/2; while(uU[mid+1]){ if(u){ left[j]=u-U[i+1-j]; right[j]=U[i+j]-u; saved = 0.0; for(r=0;r","date":"2023-11-12","objectID":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.5B样条基函数的计算","uri":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/#计算导数"},{"categories":null,"content":"令$U={u_0,u_1,u_2,…,u_m}$为节点矢量，假设我们感兴趣的是$p$次基函数，并假设$u$是固定的，$u \\in [u_i,u_{i+1}]$ 计算节点区间的下标通过二分法搜索 //n 控制点的数量减一 //p 曲线的次数 //u 要查找的参数值 //U 节点向量数组 int FindSpan(n,p,u,U){ if(u == U[n+1]) return n low = p; hight = n+1; mid = (low+hight)/2; while(uU[mid+1]){ if(u){ left[j]=u-U[i+1-j]; right[j]=U[i+j]-u; saved = 0.0; for(r=0;r","date":"2023-11-12","objectID":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"2.5B样条基函数的计算","uri":"/posts/nurbs/2.5b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/#略"},{"categories":null,"content":"略 ","date":"2023-11-12","objectID":"/posts/nurbs/3.1%E5%BC%95%E8%A8%80/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"3.1引言","uri":"/posts/nurbs/3.1%E5%BC%95%E8%A8%80/#"},{"categories":null,"content":"\rB样条曲线的定义$p$次B样条曲线的定义为 $$ C(u)=\\sum_{i=0}^nN_{i,p}(u)P_i,;a\\leq u \\leq b $$ $P_i$是控制点（control point），$N_{i,p}(u)$是定义在非周期非均匀的接电视了上的$p$次B样条基函数，由控制点构成的多边形称为控制多边形（control polygon） $$ U={\\underbrace{a,…,a}{p+1},u{p+1},…,u_{m-p-1},\\underbrace{b,…,b}_{p+1}} $$ 计算B样条曲线上的点对于固定的$u$值，计算对应的点分以下步骤 找到$u$所在的节点区间 计算非零基函数 将非零基函数的值与相应的控制点相乘，在求和 算法如下 CurvePoint(n,p,U,P,u,C) { span = FindSpan(n,p,u,U); BasisFuns(span,u,p,U,N); C=0.0; for(i=0;i\u003c=p;i++\u003e){ C=C+N[i]*P[span-p+i] } } B样条曲线的性质 如果$n=p,U={0,…,0,1,…,1}$,那么$C(u)$是Bezier曲线 $C(u)$是分段多项式曲线，次数$p$\\控制点个数$n+1$和节点个书$m+1$满足关系$$n+p+1$$ 端点插值性$C(0)=P_0,C(1)=P_n$ 仿射不变性，无论是对B样条曲线还是对控制点仿射变换，所得曲线仍旧是B样条曲线 强凸包性，曲线在控制点多边形的凸包内 局部修改性，移动$P_i$只改动$C(u)$在区间$[u_i,u_{i+p+1})$上的形状 曲线的次数越低，B样条曲线越靠近它的控制多边形 当$u$经过一个节点时，原来起作用的第一个$N_{i,p}(u)$停止作用，原来起作用的最后一个基函数的下一个$N_{i,p}(u)$开始起作用 变差减少性，任何一个平面与曲线的交点个数不多于它和控制多边形的交点个数 ","date":"2023-11-12","objectID":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"3.2B样条曲线的定义和性质","uri":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/#"},{"categories":null,"content":"\rB样条曲线的定义$p$次B样条曲线的定义为 $$ C(u)=\\sum_{i=0}^nN_{i,p}(u)P_i,;a\\leq u \\leq b $$ $P_i$是控制点（control point），$N_{i,p}(u)$是定义在非周期非均匀的接电视了上的$p$次B样条基函数，由控制点构成的多边形称为控制多边形（control polygon） $$ U={\\underbrace{a,…,a}{p+1},u{p+1},…,u_{m-p-1},\\underbrace{b,…,b}_{p+1}} $$ 计算B样条曲线上的点对于固定的$u$值，计算对应的点分以下步骤 找到$u$所在的节点区间 计算非零基函数 将非零基函数的值与相应的控制点相乘，在求和 算法如下 CurvePoint(n,p,U,P,u,C) { span = FindSpan(n,p,u,U); BasisFuns(span,u,p,U,N); C=0.0; for(i=0;i\u003c=p;i++\u003e){ C=C+N[i]*P[span-p+i] } } B样条曲线的性质 如果$n=p,U={0,…,0,1,…,1}$,那么$C(u)$是Bezier曲线 $C(u)$是分段多项式曲线，次数$p$\\控制点个数$n+1$和节点个书$m+1$满足关系$$n+p+1$$ 端点插值性$C(0)=P_0,C(1)=P_n$ 仿射不变性，无论是对B样条曲线还是对控制点仿射变换，所得曲线仍旧是B样条曲线 强凸包性，曲线在控制点多边形的凸包内 局部修改性，移动$P_i$只改动$C(u)$在区间$[u_i,u_{i+p+1})$上的形状 曲线的次数越低，B样条曲线越靠近它的控制多边形 当$u$经过一个节点时，原来起作用的第一个$N_{i,p}(u)$停止作用，原来起作用的最后一个基函数的下一个$N_{i,p}(u)$开始起作用 变差减少性，任何一个平面与曲线的交点个数不多于它和控制多边形的交点个数 ","date":"2023-11-12","objectID":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"3.2B样条曲线的定义和性质","uri":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/#b样条曲线的定义"},{"categories":null,"content":"\rB样条曲线的定义$p$次B样条曲线的定义为 $$ C(u)=\\sum_{i=0}^nN_{i,p}(u)P_i,;a\\leq u \\leq b $$ $P_i$是控制点（control point），$N_{i,p}(u)$是定义在非周期非均匀的接电视了上的$p$次B样条基函数，由控制点构成的多边形称为控制多边形（control polygon） $$ U={\\underbrace{a,…,a}{p+1},u{p+1},…,u_{m-p-1},\\underbrace{b,…,b}_{p+1}} $$ 计算B样条曲线上的点对于固定的$u$值，计算对应的点分以下步骤 找到$u$所在的节点区间 计算非零基函数 将非零基函数的值与相应的控制点相乘，在求和 算法如下 CurvePoint(n,p,U,P,u,C) { span = FindSpan(n,p,u,U); BasisFuns(span,u,p,U,N); C=0.0; for(i=0;i\u003c=p;i++\u003e){ C=C+N[i]*P[span-p+i] } } B样条曲线的性质 如果$n=p,U={0,…,0,1,…,1}$,那么$C(u)$是Bezier曲线 $C(u)$是分段多项式曲线，次数$p$\\控制点个数$n+1$和节点个书$m+1$满足关系$$n+p+1$$ 端点插值性$C(0)=P_0,C(1)=P_n$ 仿射不变性，无论是对B样条曲线还是对控制点仿射变换，所得曲线仍旧是B样条曲线 强凸包性，曲线在控制点多边形的凸包内 局部修改性，移动$P_i$只改动$C(u)$在区间$[u_i,u_{i+p+1})$上的形状 曲线的次数越低，B样条曲线越靠近它的控制多边形 当$u$经过一个节点时，原来起作用的第一个$N_{i,p}(u)$停止作用，原来起作用的最后一个基函数的下一个$N_{i,p}(u)$开始起作用 变差减少性，任何一个平面与曲线的交点个数不多于它和控制多边形的交点个数 ","date":"2023-11-12","objectID":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"3.2B样条曲线的定义和性质","uri":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/#计算b样条曲线上的点"},{"categories":null,"content":"\rB样条曲线的定义$p$次B样条曲线的定义为 $$ C(u)=\\sum_{i=0}^nN_{i,p}(u)P_i,;a\\leq u \\leq b $$ $P_i$是控制点（control point），$N_{i,p}(u)$是定义在非周期非均匀的接电视了上的$p$次B样条基函数，由控制点构成的多边形称为控制多边形（control polygon） $$ U={\\underbrace{a,…,a}{p+1},u{p+1},…,u_{m-p-1},\\underbrace{b,…,b}_{p+1}} $$ 计算B样条曲线上的点对于固定的$u$值，计算对应的点分以下步骤 找到$u$所在的节点区间 计算非零基函数 将非零基函数的值与相应的控制点相乘，在求和 算法如下 CurvePoint(n,p,U,P,u,C) { span = FindSpan(n,p,u,U); BasisFuns(span,u,p,U,N); C=0.0; for(i=0;i\u003c=p;i++\u003e){ C=C+N[i]*P[span-p+i] } } B样条曲线的性质 如果$n=p,U={0,…,0,1,…,1}$,那么$C(u)$是Bezier曲线 $C(u)$是分段多项式曲线，次数$p$\\控制点个数$n+1$和节点个书$m+1$满足关系$$n+p+1$$ 端点插值性$C(0)=P_0,C(1)=P_n$ 仿射不变性，无论是对B样条曲线还是对控制点仿射变换，所得曲线仍旧是B样条曲线 强凸包性，曲线在控制点多边形的凸包内 局部修改性，移动$P_i$只改动$C(u)$在区间$[u_i,u_{i+p+1})$上的形状 曲线的次数越低，B样条曲线越靠近它的控制多边形 当$u$经过一个节点时，原来起作用的第一个$N_{i,p}(u)$停止作用，原来起作用的最后一个基函数的下一个$N_{i,p}(u)$开始起作用 变差减少性，任何一个平面与曲线的交点个数不多于它和控制多边形的交点个数 ","date":"2023-11-12","objectID":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/:0:0","series":["非均匀有理B样条笔记"],"tags":null,"title":"3.2B样条曲线的定义和性质","uri":"/posts/nurbs/3.2b%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8/#b样条曲线的性质"},{"categories":null,"content":"\rR*Tree:一种高效稳定的点和矩形访问方法\r摘要R树是最流行的矩形访问方法之一，但是R*Tree性能明显优于RTree，它可以同时有效地支持点和空间数据，并且它的实现成本仅略高于其他R树 边界矩形的边距或重叠进行最小化， ChooseSubtree设 N 为root node if N是叶子节点 return N else if N的子节点是叶子节点 选择子节点中，包含新数据的矩形后，最少扩张的节点 else 选择子节点中，包含新数据的矩形后，最少扩张的节点,将 N 设置为这个节点的子节点，再重复 ","date":"0001-01-01","objectID":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":null,"title":"","uri":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/#rtree一种高效稳定的点和矩形访问方法"},{"categories":null,"content":"\rR*Tree:一种高效稳定的点和矩形访问方法\r摘要R树是最流行的矩形访问方法之一，但是R*Tree性能明显优于RTree，它可以同时有效地支持点和空间数据，并且它的实现成本仅略高于其他R树 边界矩形的边距或重叠进行最小化， ChooseSubtree设 N 为root node if N是叶子节点 return N else if N的子节点是叶子节点 选择子节点中，包含新数据的矩形后，最少扩张的节点 else 选择子节点中，包含新数据的矩形后，最少扩张的节点,将 N 设置为这个节点的子节点，再重复 ","date":"0001-01-01","objectID":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":null,"title":"","uri":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/#摘要"},{"categories":null,"content":"\rR*Tree:一种高效稳定的点和矩形访问方法\r摘要R树是最流行的矩形访问方法之一，但是R*Tree性能明显优于RTree，它可以同时有效地支持点和空间数据，并且它的实现成本仅略高于其他R树 边界矩形的边距或重叠进行最小化， ChooseSubtree设 N 为root node if N是叶子节点 return N else if N的子节点是叶子节点 选择子节点中，包含新数据的矩形后，最少扩张的节点 else 选择子节点中，包含新数据的矩形后，最少扩张的节点,将 N 设置为这个节点的子节点，再重复 ","date":"0001-01-01","objectID":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":null,"title":"","uri":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/#choosesubtree"},{"categories":null,"content":"\rsplit of the R*-tree\rSplit 调用 ChooseSplltAxis 以确定执行拆分的垂直轴 调用 ChooseSplltIndex 以确定沿该轴分成两组的最佳分布 将条目分成两组 ","date":"0001-01-01","objectID":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/:0:1","series":null,"tags":null,"title":"","uri":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/#split-of-the-r-tree"},{"categories":null,"content":"\rsplit of the R*-tree\rSplit 调用 ChooseSplltAxis 以确定执行拆分的垂直轴 调用 ChooseSplltIndex 以确定沿该轴分成两组的最佳分布 将条目分成两组 ","date":"0001-01-01","objectID":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/:0:1","series":null,"tags":null,"title":"","uri":"/posts/datastructure/r-start-tree%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%A8%B3%E5%AE%9A%E7%9A%84%E7%82%B9%E5%92%8C%E7%9F%A9%E5%BD%A2%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/#split"},{"categories":null,"content":"\rR树:一种用于空间搜索的动态索引结构","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#r树一种用于空间搜索的动态索引结构"},{"categories":null,"content":"\rR树属性M 为一个节点的最大条目数 m\u003c=M/2 为指定节点中最小条目数的参数 根节点(root node) 非叶子节点(non-leaf node)存放的是这些数据的“边界”，或者说索引 叶子节点（leaf node）存放的是真实存在的数据 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:1","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#r树属性"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#r树的基本性质"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#search"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#insertion"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#chooseleaf"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#adjusttree"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#delete"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#findleaf"},{"categories":null,"content":"\rR树的基本性质 叶子结点包含有m至M个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。 对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。 每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。 对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。 R树为平衡树，所有叶子结点都位于同一层 Search给定一棵根节点为 T 的 R 树，找到其矩形与搜索矩形 S 重叠的所有索引记录 搜索子树 如果 T 不是叶子节点，则检查每个条目 E 以确定 E.I 是否与 S 重叠。对于所有重叠的 条目，在E.p上调用 Search 搜索叶子节点 如果 T 是叶子，则检查所有条目 E 以确定 E.I 是否与 S 重叠。如果是，则 E 是合格记录。 Insertion描述：将新的记录条目E插入给定的R树中。 为新记录找到合适插入的叶子结点 开始ChooseLeaf方法选择叶子结点L以放置记录E。 添加新记录至叶子结点 如果L有足够的空间来放置新的记录条目，则向L中添加E。如果没有足够的空间，则进行SplitNode方法以获得两个结点L与LL，这两个结点包含了所有原来叶子结点L中的条目与新条目E。 将变换向上传递 开始对结点L进行AdjustTree操作，如果进行了分裂操作，那么同时需要对LL进行AdjustTree操作。 对树进行增高操作 如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。 ChooseLeaf描述：选择叶子结点以放置新条目E。 Initialize 设置N为根结点。 叶子结点的检查 如果N为叶子结点，则直接返回N。 选择子树 如果N不是叶子结点，则遍历N中的结点，找出添加E.I时扩张最小的结点，并把该结点定义为F。如果有多个这样的结点，那么选择面积最小的结点。 下降至叶子结点 将N设为F，从CL2开始重复操作。 AdjustTree描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。 初始化 将N设为L。 检验是否完成 如果N为根结点，则停止操作。 调整父结点条目的最小边界矩形 设P为N的父节点，EN为指向在父节点P中指向N的条目。调整EN.I以保证所有在N中的矩形都被恰好包围。 向上传递结点分裂 如果N有一个刚刚被分裂产生的结点NN，则创建一个指向NN的条目ENN。如果P有空间来存放ENN，则将ENN添加到P中。如果没有，则对P进行SplitNode操作以得到P和PP。 升高至下一级 如果N等于L且发生了分裂，则把NN置为PP。从AT2开始重复操作。 Delete描述：将一条记录E从指定的R树中删除。 D1：[找到含有记录的叶子结点] 使用FindLeaf方法找到包含有记录E的叶子结点L。如果搜索失败，则直接终止。 D2：[删除记录] 将E从L中删除。 D3：[传递记录] 对L使用CondenseTree操作 D4：[缩减树] 当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。 FindLeaf描述：根结点为T，期望找到包含有记录E的叶子结点。 FL1：[搜索子树] 如果T不是叶子结点，则检查每一条T中的条目F，找出与E所对应的矩形相重合的F（不必完全覆盖）。对于所有满足条件的F，对其指向的孩子结点进行FindLeaf操作，直到寻找到E或者所有条目均以被检查过。 FL2：[搜索叶子结点以找到记录] 如果T是叶子结点，那么检查每一个条目是否有E存在，如果有则返回T。 CondenseTree描述：L为包含有被删除条目的叶子结点。如果L的条目数过少（小于要求的最小值m），则必须将该叶子结点L从树中删除。经过这一删除操作，L中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。 CT1：[初始化] 令N为L。初始化一个用于存储被删除结点包含的条目的链表Q。 CT2：[找到父条目] 如果N为根结点，那么直接跳转至CT6。否则令P为N 的父结点，令EN为P结点中存储的指向N的条目。 CT3：[删除下溢结点] 如果N含有条目数少于m，则从P中删除EN，并把结点N中的条目添加入链表Q中。 CT4：[调整覆盖矩形] 如果N没有被删除，则调整EN.I使得其对应矩形能够恰好覆盖N中的所有条目所对应的矩形。 CT5：[向上一层结点进行操作] 令N等于P，从CT2开始重复操作。 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:2","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#condensetree"},{"categories":null,"content":"\r节点分裂为了向包含 M 个条目的节点添加一个新条目，有必要把 M+1 个条目的集合分裂成两个节点，使得两个新节点都需要在后续搜索中被检查的可能性尽可能小。由于决定是否访问一个节点取决于它的覆盖矩形是否与搜索区域重叠，所以分割后的两个覆盖矩形的总面积应该最小。下图说明了这一点。 “坏分割”情况下覆盖矩形的面积比“好分割”情况下的大得多。 下列是将 M+1 个条目的集合分成两组的算法： 穷举算法 二次分裂 A Quadratic-Cost Algorithm 会造成很多重叠区域 该算法试图找到一个小面积的分割，但不能保证找到一个尽可能小的区域。成本在 M 中是二次方，在维数方面是线性的。该算法选择 M+1 个条目中的两个作为两个新组的第一个元素，方法是选择放在同一组中将浪费最多区域的两个条目组成的对，即覆盖两个条目的矩形区域，减去条目本身的区域将是最大的。然后将剩余的条目一次一个地分配给组。在每一步中，计算将每个剩余条目添加到每个组所需的面积扩展，分配的条目是显示两组之间最大差异的条目。 线性分裂 A Linear-Cost Algorithm 会造成更多的重叠区域，但是构建速度快一点 该算法在 M 和维数方面是线性的。 Linear Split 与 Quadratic Split 仅区别在不同版本的PickSeeds。 沿所有维度查找极端矩形 沿每个维度，找到其矩形具有最高低边和最低高边的条目。记录分离。 调整矩形簇的形状 通过沿相应维度除以整个集合的宽度来标准化分离。 选择最极端的对 选择沿任何维度具有最大归一化分离的对。 [从B树、B+树、B*树谈到R 树]https://blog.csdn.net/v_JULY_v/article/details/6530142/ https://blog.csdn.net/MongChia1993/article/details/69941783#toc_13 ","date":"0001-01-01","objectID":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/:0:3","series":null,"tags":null,"title":"","uri":"/posts/datastructure/rtree%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%90%9C%E7%B4%A2%E7%9A%84%E5%8A%A8%E6%80%81%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/#节点分裂"}]